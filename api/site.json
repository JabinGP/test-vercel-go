[{"slug":"images/","title":"","content":"---\nheadless: true\n---","excerpt":""},{"slug":"posts/code/centos-yum-update-git","title":"CentOS使用Yum升级Git到2.1x新版本","content":"---\ntitle: \"CentOS使用Yum升级Git到2.1x新版本\"\ndate: 2020-12-08T21:13:54+08:00\ncategories: [\"code\"]\ntags: [\"linux\", \"centos\", \"git\", \"update\", \"yum\"]\ndraft: false\n---\n\n使用yum最多只能安装到1.8，版本太旧了，下载源码手动编译安装？先不说国内下载官网包2kB/s的速度，就是下载下来了编译也麻烦啊，包管理是吃干饭的嘛？\n\n其实只要换个源，重新下载就好了\n\n先卸载旧版\n\n```cmd\nyum remove git\n```\n\n添加新源后安装新版\n\n```cmd\nyum install -y https://centos7.iuscommunity.org/ius-release.rpm\nyum install -y git2u\n```\n\n检验\n\n```cmd\ngit version    \n```\n\n最后附带我的安装过程\n\n```cmd\nroot@izwz957qhjacaocedubzjjz /tmp/installGit   [20:43:53] \n> # yum install -y https://centos7.iuscommunity.org/ius-release.rpm\n已加载插件：fastestmirror\nius-release.rpm                    | 8.2 kB     00:00     \n正在检查 /var/tmp/yum-root-6VAioA/ius-release.rpm: ius-release-2-1.el7.ius.noarch\n/var/tmp/yum-root-6VAioA/ius-release.rpm 将被安装\n正在解决依赖关系\n--> 正在检查事务\n---> 软件包 ius-release.noarch.0.2-1.el7.ius 将被 安装\n--> 正在处理依赖关系 epel-release = 7，它被软件包 ius-release-2-1.el7.ius.noarch 需要\nLoading mirror speeds from cached hostfile\n--> 正在检查事务\n---> 软件包 epel-release.noarch.0.7-12 将被 安装\n--> 解决依赖关系完成\n\n依赖关系解决\n\n==========================================================\n Package       架构    版本           源             大小\n==========================================================\n正在安装:\n ius-release   noarch  2-1.el7.ius    /ius-release  4.5 k\n为依赖而安装:\n epel-release  noarch  7-12           epel           15 k\n\n事务概要\n==========================================================\n安装  1 软件包 (+1 依赖软件包)\n\n总计：19 k\n总下载量：15 k\n安装大小：29 k\nDownloading packages:\nepel-release-7-12.noarch.rpm         |  15 kB   00:00     \nRunning transaction check\nRunning transaction test\nTransaction test succeeded\nRunning transaction\n  正在安装    : epel-release-7-12.noarch              1/2 \n警告：/etc/yum.repos.d/epel.repo 已建立为 /etc/yum.repos.d/epel.repo.rpmnew \n  正在安装    : ius-release-2-1.el7.ius.noarch        2/2 \n  验证中      : ius-release-2-1.el7.ius.noarch        1/2 \n  验证中      : epel-release-7-12.noarch              2/2 \n\n已安装:\n  ius-release.noarch 0:2-1.el7.ius                        \n\n作为依赖被安装:\n  epel-release.noarch 0:7-12                              \n\n完毕！\n                                                          \nroot@izwz957qhjacaocedubzjjz /tmp/installGit   [20:44:05] \n> # yum install -y git2u                                 \n已加载插件：fastestmirror\nius                                | 1.3 kB     00:00     \nius/x86_64/primary                   | 129 kB   00:01     \nLoading mirror speeds from cached hostfile\nius                                               538/538\n正在解决依赖关系\n--> 正在检查事务\n---> 软件包 git2u.x86_64.0.2.16.5-1.ius.el7 将被 安装\n--> 正在处理依赖关系 git2u-perl-Git = 2.16.5-1.ius.el7，它被软件包 git2u-2.16.5-1.ius.el7.x86_64 需要\n--> 正在处理依赖关系 git2u-core-doc = 2.16.5-1.ius.el7，它被软件包 git2u-2.16.5-1.ius.el7.x86_64 需要\n--> 正在处理依赖关系 git2u-core = 2.16.5-1.ius.el7，它被软件包 git2u-2.16.5-1.ius.el7.x86_64 需要\n--> 正在处理依赖关系 perl(Git::I18N)，它被软件包 git2u-2.16.5-1.ius.el7.x86_64 需要\n--> 正在处理依赖关系 perl(Git)，它被软件包 git2u-2.16.5-1.ius.el7.x86_64 需要\n--> 正在处理依赖关系 libsecret-1.so.0()(64bit)，它被软件包 git2u-2.16.5-1.ius.el7.x86_64 需要\n--> 正在检查事务\n---> 软件包 git2u-core.x86_64.0.2.16.5-1.ius.el7 将被 安装\n---> 软件包 git2u-core-doc.noarch.0.2.16.5-1.ius.el7 将被 安装\n---> 软件包 git2u-perl-Git.noarch.0.2.16.5-1.ius.el7 将被 安装\n---> 软件包 libsecret.x86_64.0.0.18.6-1.el7 将被 安装\n--> 解决依赖关系完成\n\n依赖关系解决\n\n==========================================================\n Package         架构    版本                 源     大小\n==========================================================\n正在安装:\n git2u           x86_64  2.16.5-1.ius.el7     ius   1.1 M\n为依赖而安装:\n git2u-core      x86_64  2.16.5-1.ius.el7     ius   5.5 M\n git2u-core-doc  noarch  2.16.5-1.ius.el7     ius   2.4 M\n git2u-perl-Git  noarch  2.16.5-1.ius.el7     ius    68 k\n libsecret       x86_64  0.18.6-1.el7         base  153 k\n\n事务概要\n==========================================================\n安装  1 软件包 (+4 依赖软件包)\n\n总下载量：9.2 M\n安装大小：42 M\nDownloading packages:\n警告：/var/cache/yum/x86_64/7/ius/packages/git2u-2.16.5-1.ius.el7.x86_64.rpm: 头V4 RSA/SHA256 Signature, 密钥 ID 4b274df2: NOKEY\ngit2u-2.16.5-1.ius.el7.x86_64.rpm 的公钥尚未安装\n(1/5): git2u-2.16.5-1.ius.el7.x86_64 | 1.1 MB   00:02     \n(2/5): git2u-core-doc-2.16.5-1.ius.e | 2.4 MB   00:00     \n(3/5): git2u-core-2.16.5-1.ius.el7.x | 5.5 MB   00:03     \n(4/5): libsecret-0.18.6-1.el7.x86_64 | 153 kB   00:00     \n(5/5): git2u-perl-Git-2.16.5-1.ius.e |  68 kB   00:00     \n----------------------------------------------------------\n总计                         2.6 MB/s | 9.2 MB  00:03     \n从 file:///etc/pki/rpm-gpg/RPM-GPG-KEY-IUS-7 检索密钥\n导入 GPG key 0x4B274DF2:\n 用户ID     : \"IUS (7) <dev@ius.io>\"\n 指纹       : c958 7a09 a11f d706 4f0c a0f4 e558 0725 4b27 4df2\n 软件包     : ius-release-2-1.el7.ius.noarch (installed)\n 来自       : /etc/pki/rpm-gpg/RPM-GPG-KEY-IUS-7\nRunning transaction check\nRunning transaction test\nTransaction test succeeded\nRunning transaction\n  正在安装    : git2u-core-2.16.5-1.ius.el7.x86_64    1/5 \n  正在安装    : git2u-core-doc-2.16.5-1.ius.el7.noa   2/5 \n  正在安装    : libsecret-0.18.6-1.el7.x86_64         3/5 \n  正在安装    : git2u-perl-Git-2.16.5-1.ius.el7.noa   4/5 \n  正在安装    : git2u-2.16.5-1.ius.el7.x86_64         5/5 \n  验证中      : git2u-2.16.5-1.ius.el7.x86_64         1/5 \n  验证中      : git2u-core-doc-2.16.5-1.ius.el7.noa   2/5 \n  验证中      : git2u-core-2.16.5-1.ius.el7.x86_64    3/5 \n  验证中      : git2u-perl-Git-2.16.5-1.ius.el7.noa   4/5 \n  验证中      : libsecret-0.18.6-1.el7.x86_64         5/5 \n\n已安装:\n  git2u.x86_64 0:2.16.5-1.ius.el7                         \n\n作为依赖被安装:\n  git2u-core.x86_64 0:2.16.5-1.ius.el7                    \n  git2u-core-doc.noarch 0:2.16.5-1.ius.el7                \n  git2u-perl-Git.noarch 0:2.16.5-1.ius.el7                \n  libsecret.x86_64 0:0.18.6-1.el7                         \n\n完毕！\n                                                          \nroot@izwz957qhjacaocedubzjjz /tmp/installGit   [20:44:22] \n> # git version                                       \n\ngit version 2.16.5\n```\n\n> 感谢[https://www.cnblogs.com/jhxxb/p/10571227.html](https://www.cnblogs.com/jhxxb/p/10571227.html)\n","excerpt":"使用yum最多只能安装到1.8，版本太旧了，下载源码手动编译安装？先不说国内下载官网包2kB/s的速度，就是下载下来了编译也麻烦啊，包管理是吃干饭的嘛？ 其实只要换个源，重新下载就好了 先卸载旧版 添加新源后安装新版 检验 最后附带我的安装过程 感谢 https://www.cnblogs.com/jhxxb/p…"},{"slug":"posts/code/cookie-session-login","title":"Cookie、Session是如何保持登录状态的？","content":"---\ntitle: \"Cookie、Session是如何保持登录状态的？\"\ndate: 2020-12-08T21:05:07+08:00\ncategories: [\"code\"]\ntags: [\"cookie\",\"session\",\"login\",\"http\"]\ndraft: false\n---\n\n> 无论是web应用还是原生app应用，只要涉及网络连接，基本就离不开登录注册，我们注册完成后登录，这个状态就被保持下来了，我们下次打开app，应用就已经处于登录状态了，不需要我们重复登录，非常人性化，感觉服务器好像会“记得”我们每一个人一样，“记得”你来过，就不再要求你登录了。但其实计算机在这方面是很傻的，他不是自发“记得”我们的，这篇文章就来聊聊登录状态的保持是怎么实现的。\n\n### HTTP协议\n\n要弄明白下面说的东西，就得先了解一下HTTP协议，繁琐的概念就不多赘述了，这里主要注意一点，**HTTP协议是无状态的**，什么叫无状态？我们从一个故事讲起：\n>你去一家水果店买水果，你看到他们的桃子很鲜美，于是你大赞了老板的桃子后并买了一斤。你回家尝了桃子后觉得非常好吃，你决定第二天继续购买。当你第二天开开心心的过来找老板，跟他说“你家的水果真的很好吃，再来一斤我昨天买的那个水果”，但是发现老板并不知道你昨天买过什么，于是你非常生气，跟老板说“我昨天还夸了很久你的水果，你怎么就不记得了？”一顿理论后你发现老板始终不记得你昨天干过什么事，最后你只好跟老板表明要买一斤桃子，交易后灰溜溜地离开。\n\n这个故事中的老板就是无状态的，对他来说，他只知道某个人要买什么东西，给了多少钱，要买什么水果，要找多少钱，对于过程中的其它信息如是“谁”来买，他不会记得，他只会针对买卖本身进行处理。\n\n### HTTP为什么无状态？\n\n- 首先什么是无状态？\n无状态就意味着每个请求之间的不会直接地相互影响，对于每个请求，同样的请求参数就会得到同样的结果。\n\n- 回到HTTP协议中：\n最初的需求是请求HTML界面显示出静态网站，并不如现在那么复杂丰富，用户A点击某个网址浏览到的页面和用户B点击同样网址浏览到的页面是完全一模一样的，也就是服务器并不会对每个不同的人有特殊处理，服务器只对请求负责，不对发起请求的人负责。因此在HTTP设计中，每个请求都是独立的，每个请求中都包含了请求的所有数据，服务器只对请求和请求中携带的信息进行处理后返回特定结果。就如上面的那个水果店，老板只根据要买什么水果，水果多少钱，给了多少钱，进行处理，如果你跟他说你昨天与他交谈如何，他无动于衷，因为他完全不会记得这些事情，他完全不记得你曾来过。\n\n### HTTP如何保存登录状态？\n\n>前面说到，HTTP是无状态的，每个请求之间的不会直接地相互影响。\n\n当我**第一次调用用户名密码验证接口**的时候，我需要输入账号、密码，服务器收到请求之后，就会根据账号去数据库取你的密码和你输入的密码进行比对，然后返回一个“密码正确”或“密码错误”。而问题在于当我**第二次访问这个接口**的时候，服务器依旧会执行他的职能：收到我发送的账号和密码，然后去数据库取数据进行比对后返回比对结果，对于服务器来说，**每个请求不过是做了类似1+1是否等于2的判断然后返回结果而已**。\n\n**我想要服务器能够记住我已经调用过一次登录接口并且以及成功了这个状态，应该怎么办？**\n\n我们可以很自然的想到，服务器不知道我们登录过的原因是因为没有**记下来**，要保持登录状态，只要让服务器记下来就可以了。我们可以在服务器专门设置一个存储，每次只要我验证账号和密码成功，就在这个存储里面存下“JabinGP登录成功”（这个JabinGP是用户名），这样我们服务器就记得JabinGP登录过了。\n\n现在服务器已经知道JabinGP登录过了，但是这就够了吗？不够，因为HTTP请求并不会自动标明“这是JabinGP发起的请求”，所以我们还要做点工作让服务器能知道“这是JabinGP发起的请求”，然后服务器才好去存储下来的登录状态里面找“JabinGP登录成功”这个标志。怎么做？我们可以在调用请求的时候把自己的用户名加进请求的参数中，比如Get请求的URl参数、Post请求的请求Body中，这样服务器就可以根据我们的用户名判断我们有没有登录过了。\n\n_这样我们就初步的把登录状态保存了下来，其实这样的验证非常粗糙，所以基于这个思想，产生了下面的技术。_\n\n### 什么是Cookie？\n\n有很多品牌的Cookie，比如说蓝罐，广州酒家......什么？哦哦不好意思我搞错了，这个才是Cookie：Cookie就是存储在客户端的一小段数据，它可以存在硬盘中（永久Cookie），也可以存在内存中（临时Cookie）\n\n### 什么是Session？\n\nSession是指服务器为某个会话开启的一段独特的存储空间（会话是指一个终端用户与交互系统进行通讯的过程，比如说我先登录，再查看我的邮箱内容，这个过程就是一个会话），一个Session用唯一的SessionId对应一段存储空间。\n\n### Cookie和Session是怎么用的？\n\n首先从概念上，Cookie和Session都是用来存东西的，问题在于它们都用来存什么，以及它们都做了什么？\n结合前面分析：\n\n- Cookie的出现，代替了手动设置标识的步骤，因为我们可以把标识设置在Cookie里面，设置了Cookie后，Cookie就存在了，下次请求Cookie就会自动发送给服务器，这样我们就不用给每个请求都很麻烦地手动设置一个标识（比如前面分析中的用户名）。\n- Session其实就是代替了在服务器存储状态的步骤，SessionId可以对应一段存储空间，这段空间对每个会话都是唯一的（比如我登录后，就产生了一个会话，也产生了一段存储空间，这段存储空间只被我当前的登录状态下的活动所使用，别人是用不到的），这样就可以确保每个登录状态都有对应的一小段存储空间来写入一些中间过程的数据。\n\n### Cookie和Session的关系？\n\n看了上面的Cookie和Session的解释，以及Cookie和Session的使用，就可以发现它们两个其实完全不冲突，甚至这两者是需要相互配合的，因为Cookie是在客户端的存储，Session是在服务端的存储，Session的存储需要SessionId来一一对应，这样才不会出现xxx获得了JabinGP的登录状态然后用JabinGP的钱买东西这样的情况，SessionId则需要通过Cookie保存在用户客户端中，客户端通过保存在Cookie的SessionId来标识自己，表明“我就是JabinGP”。\n\n到这里差不多就简单介绍完Cookie和Session以及登录状态的保持了，以上都是个人理解，用于个人学习记录，如有错误，请评论指正。\n","excerpt":"无论是web应用还是原生app应用，只要涉及网络连接，基本就离不开登录注册，我们注册完成后登录，这个状态就被保持下来了，我们下次打开app…"},{"slug":"posts/code/docker-install-mongo","title":"Docker安装MongoDB","content":"---\ntitle: \"Docker安装MongoDB\"\ndate: 2020-12-12T17:28:11+08:00\ncategories: [\"code\"]\ntags: [\"docker\", \"mongodb\"]\ndraft: false\n---\n\n## 拉取镜像\n\n```cmd\ndocker pull mongo:latest\n```\n\n## 运行镜像\n\n```cmd\ndocker run -itd --name mongo -p 27017:27017 mongo --auth\n```\n\n- --auth：Enables authorization to control user’s access to database resources and operations. When authorization is enabled, MongoDB requires all clients to authenticate themselves first in order to determine the access for the client.\nConfigure users via the mongo shell. If no users exist, the localhost interface will continue to have access to the database until you create the first user。\n\n## 进入容器添加用户\n\n进入容器并且直接运行mongo-shell，选择数据库为`admin`\n\n```cmd\ndocker exec -it mongo mongo admin\n```\n\n创建用户并尝试连接\n\n```cmd\ndb.createUser({ user:'admin',pwd:'123456',roles:[ { role:'userAdminAnyDatabase', db: 'admin'},\"readWriteAnyDatabase\"]});\ndb.auth('admin', '123456')\n```\n\n## 验证账户权限\n\n运行一些简单的指令来验证账户的有效性\n\n```cmd\n> show dbs\nadmin   0.000GB\nconfig  0.000GB\nlocal   0.000GB\n> show users\n{\n        \"_id\" : \"admin.admin\",\n        \"userId\" : UUID(\"dc5760ea-c8c1-4f40-af5b-7d9d53779842\"),\n        \"user\" : \"admin\",\n        \"db\" : \"admin\",\n        \"roles\" : [\n                {\n                        \"role\" : \"userAdminAnyDatabase\",\n                        \"db\" : \"admin\"\n                }\n        ],\n        \"mechanisms\" : [\n                \"SCRAM-SHA-1\",\n                \"SCRAM-SHA-256\"\n        ]\n}\n```\n","excerpt":"拉取镜像 运行镜像 --auth：Enables authorization to control user’s access to database resources and operations. When authorization is enabled, MongoDB requires all…"},{"slug":"posts/code/docker-install-redis","title":"docker安装redis、redis-cli测试连接、python api测试连接。","content":"---\ntitle: \"docker安装redis、redis-cli测试连接、python api测试连接。\"\ndate: 2020-12-08T21:41:35+08:00\ncategories: [\"code\"]\ntags: [\"docker\", \"redis\", \"python\", \"redis-cli\"]\ndraft: false\n---\n\n## 拉取镜像、启动\n\n拉取镜像\n\n```cmd\ndocker pull redis\n```\n\n查看已有镜像\n\n```cmd\ndocker images\n```\n\n启动 docker\n\n```cmd\ndocker run -itd --name redis -p 6379:6379 redis\n```\n\n查看 docker 运行的容器状态\n\n```cmd\ndocker ps\n```\n\n## 测试使用\n\n### 在容器内部测试连接\n\n```cmd\ndocker exec -it redis /bin/bash\n```\n\n进入容器内部后\n\n```bash\nroot@2ff6e2c47742:/data# redis-cli\n127.0.0.1:6379> set username jabin\nOK\n127.0.0.1:6379> get username\n\"jabin\"\n127.0.0.1:6379>\n```\n\n### 在容器外部测试连接\n\nredis 容器绑定到了宿主主机的**6379**端口，因此可以认为 redis 跑在了本机的**6379**端口。\n\n#### 使用 redis-cli 连接\n\n如果本机（宿主机）安装了**redis-cli**，可以使用本机的**redis-cli**测试。\n\n```bash\n➜  Desktop redis-cli -h 127.0.0.1 -p 6379\n127.0.0.1:6379> get username\n\"jabin\"\n127.0.0.1:6379>\n```\n\n#### 使用 python 的 api 连接\n\n```py\nimport redis\n\nr = redis.StrictRedis(host='127.0.0.1', port=6379)\n\nprint(str(r.get(\"username\"), encoding=\"utf-8\"))\n```\n\n输出\n\n```cmd\njabin\n```\n","excerpt":"拉取镜像、启动 拉取镜像 查看已有镜像 启动 docker 查看 docker 运行的容器状态 测试使用 在容器内部测试连接 进入容器内部后 在容器外部测试连接 redis 容器绑定到了宿主主机的 6379 端口，因此可以认为 redis 跑在了本机的 6379 端口。 使用 redis-cli…"},{"slug":"posts/code/go-orm-demo","title":"Go语言ORM框架快速上手，ORM操作Mysql数据库示例","content":"---\ntitle: \"Go语言ORM框架快速上手，ORM操作Mysql数据库示例\"\ndate: 2020-12-08T21:38:19+08:00\ncategories: [\"code\"]\ntags: [\"mysql\", \"orm\", \"gorm\", \"xorm\", \"database\"]\ndraft: false\n---\n\n> 直接上Github[https://github.com/JabinGP/demo-gomysql](https://github.com/JabinGP/demo-gomysql)\n\n## 说明\n\n代码有master和gorm两个分支，master分支用的是xorm，gorm不言而喻。\n\n两个分支都是简单的单表查询，比较便于理解学习框架。\n\n两个分支都是只需要补齐mysql的配置文件，提前建好对应库，不需要建表就可以直接跑起来的，便于快速看到效果，具体的启动方式在README中有解释。\n\n## 使用感受\n\n> 具体的就不多说了，都在代码里面，也有详细的注释，主要讲讲体验。\n> 如果你没有决定用哪个，信我就选`xorm` 。\n\n### 单表\n\n两个框架大同小异，但是个人感觉xorm的文档，以及api的逻辑性上比较顺应我的想法（大概就是我猜它会怎么去暴露api给我用，然后用了之后发现确实是这样的）。\n\nGorm有几点我觉得不太好用：\n\n1. 为了实现软删除，Gorm自带一个model，官方推荐组合使用struct，但是实际上使用了这个以后，结构体字面量就无法直接指定id了。。{ID:xxx}会报语法错误，如果要嵌套使用{{ID:xx}}就会爆参数不完整的错误，这样在使用结构体指定字段查询的时候不能直接指定id就非常麻烦，必须先初始化一个结构体，在xxx.ID=xxx指定。\n2. select找不到记录的时候竟然返回了err，这个我觉得不太合理，找不到值怎么能是错误呢。\n\n### 多表\n\n#### Gorm\n\nGorm在我的一个简易demo[iris项目实战简易聊天室](https://github.com/JabinGP/demo-chatroom)中使用到，\n其中Gorm在另一个简单的demo中尝试使用，Gorm在项目中用到级联查询的时候非常难受，翻看了很多遍官方文档，官方文档在这一块说得不是很清楚，也没有什么示例，最后是自己不断尝试组合实现的。\n\n#### Xorm\n\n由于还没有使用过Xorm做项目，只是写了简单的单表示例，Xorm似乎也支持级联查询，但我更看重的是Xorm在文档中提供了直接执行SQL的方法，我更倾向于使用原生SQL加传入结构体指针扫描的形式完成级联查询，接下来打算将[iris项目实战简易聊天室](https://github.com/JabinGP/demo-chatroom)用xorm重构，看看效果后再对本文进行更新，不过个人感觉xorm应该是会更好用的。\n","excerpt":"直接上Github https://github.com/JabinGP/demo-gomysql 说明 代码有master和gorm两个分支，master分支用的是xorm，gorm不言而喻。 两个分支都是简单的单表查询，比较便于理解学习框架。 两个分支都是只需要补齐mysql…"},{"slug":"posts/code/goget-goinstall-hugo","title":"记一次go get安装hugo的坑、go module、goinstall、gobuild。","content":"---\ntitle: \"记一次go get安装hugo的坑、go module、goinstall、gobuild。\"\ndate: 2020-12-08T21:44:29+08:00\ncategories: [\"code\"]\ntags: [\"golang\", \"hugo\"]\ndraft: false\n---\n\n> 该文章的golang版本为`go version go1.14.5 darwin/amd64`\n\n## 心路历程\n\n### 1. 报错\n\n晚上本来想装个hugo玩玩，hugo提供了挺多安装方法比如最直接的二进制包安装、homebrew等包管理安装、docker，正好电脑里也有golang的环境，平时装go写的软件也很方便`go get`就解决了，自然而然想到`go get -v github.com/gohugoio/hugo`，看着控制台Download了半天最后竟然给我报了个错：\n\n```cmd\npackage github.com/jdkato/prose/transform: cannot find package \"github.com/jdkato/prose/transform\" in any of:\n        /usr/local/Cellar/go/1.14.5/libexec/src/github.com/jdkato/prose/transform (from $GOROOT)\n        /Users/jabin/go/src/github.com/jdkato/prose/transform (from $GOPATH)\n```\n\n大概意思就是找不到`github.com/jdkato/prose/transform`这个包，我下意识点开[https://github.com/jdkato/prose/transform](https://github.com/jdkato/prose/transform)一探究竟，发现github确实报了404错误，说明这个包确实有点问题。\n\n### 2. 尝试\n\n然后我寻思着不对劲怎么装都装不上，打开[hugo的github仓库](https://github.com/gohugoio/hugo)看到了这样的向导：\n\n```cmd\nmkdir $HOME/src\ncd $HOME/src\ngit clone https://github.com/gohugoio/hugo.git\ncd hugo\ngo install\n```\n\n我不信邪，就试了一下先`clone`再`go install`会怎么样，然后发现竟然成功了，在golang的bin目录（在我的电脑下是`~/go/bin`）下生成了一个名为`hugo`的可执行文件。\n\n### 3. 排错\n\n我寻思着`go get`是把项目先拉下来然后编译放在`~/go/bin`下，`go install`是自己手动进入了某个项目目录下执行编译输出到`~/go/bin`，二者应该只有**自己把项目拉下来然后进入该项目**的区别，怎么会出现这样奇怪的错误。\n\n#### 3.1 灵异事件\n\n一遍思考一遍手上又执行了一遍`go get -v github.com/gohugoio/hugo`，这一遍竟然什么报错也没有，我赶紧删掉`~/go/bin`下的编译产物`hugo`，检验是否真的`go get`能够正常编译出可执行文件了，结果是**确实没有报错且正常编译出结果了**。\n\n我百思不得其解，但是回想一开始得到的错误，似乎错误中提到了两个路径：\n\n- `/usr/local/Cellar/go/1.14.5/libexec/src/github.com/jdkato/prose/transform (from $GOROOT)`\n- `/Users/jabin/go/src/github.com/jdkato/prose/transform`\n我逐一检查后发现确实两个地址都无法找到需要的这个包，于是我开始想这个项目是不是有什么问题，熟悉go包和github地址的人应该清楚，这个地址说明这个包的作者是`jdkato`，项目名是`prose`，`transform`应该是项目下的一个文件夹。\n\n#### 3.2 计算机不会耍赖皮\n\n> 写文章时[https://github.com/jdkato/prose](https://github.com/jdkato/prose)的最新commit是`c2b2f78b870e41bec89843648b04b1716a0fb9c6`\n> [hugo的github仓库](https://github.com/gohugoio/hugo)的最新commit是`c84ad8db821c10225c0e603c6ec920c67b6ce36f`\n\n于是我开始在github搜jdkato这个名字，发现了这个作者确实有prose这个项目[https://github.com/jdkato/prose](https://github.com/jdkato/prose)，点进去一看发现这个项目也的的确确没有`transform`这个文件夹。\n\n再翻看[hugo的github仓库](https://github.com/gohugoio/hugo)发现最新的release是三天前，说明hugo的代码本身没有什么问题。\n\n这时候我得出一种推论，hugo可能用了prose这个项目的老版本，老版本里存在transform这个文件夹，hugo可能是自己的golang环境里缓存了prose这个项目的老版本之类的。但是很快这种想法就被我自己推翻了，因为我的的确确在自己的电脑上`go install`成功了hugo的最新源码，并且在`go install`成功之前我还处于`package github.com/jdkato/prose/transform: cannot find`的错误中，根本不存在缓存了老版本项目代码的可能。\n\n#### 3.3 真相只有一个\n\n推测到这里，我想起来一个重要的东西，`go.mod`正是那个**可以缓存旧版本的**关键人物啊！我赶紧再翻看[hugo的github仓库](https://github.com/gohugoio/hugo)，果然发现了`go.mod`这个文件，里面也有这样一段记录：\n\n```go\nmodule github.com/gohugoio/hugo\n\nrequire (\n    ...省略\n    github.com/jdkato/prose v1.2.0\n    ...省略\n)\n\nreplace github.com/markbates/inflect => github.com/markbates/inflect v0.0.0-20171215194931-a12c3aec81a6\n\ngo 1.12\n```\n\n可以看到`require`中指出了对项目`github.com/jdkato/prose`的版本要求为`v1.2.0`，我啪的一下就打开了[https://github.com/jdkato/prose/tree/v1.2.0](https://github.com/jdkato/prose/tree/v1.2.0)，果然在`v1.2.0`这个旧版本的`tag`下有我们想要的`transform`文件夹。\n\n那么`go get`报错的真相就只有一个，`go get`获取了最新版本的`github.com/jdkato/prose`，正好最新版本的`github.com/jdkato/prose`重构了，项目结构发生了改变。而`go install`成功后`go get`也能成功的灵异事件也能说的过去了，就是因为`go install`获取到了对的版本的项目，导致`go get`也能够找到需要的文件了。\n\n#### 3.4 案件远没有结束\n\n尽管得出了一个看起来说的过去的解释，但是问题又来了：**为什么`go install`就能获取到对应的版本的项目？**\n\n我自然而然想到了`go.mod`这个关键人物，我同样得出一个大胆的推论：`go get`不会理会`go.mod`中的限制，而`go install`则会在意。\n\n#### 3.5 口说无凭，怎么证明\n\n粗略了翻阅了有关`go get`和`go install`的一些说明，发现没什么和我这个问题相关的，只好来点硬核的了，正好go也是自举的，go语言的go语言源码还是可以看看的。\n\n#### 3.6 源码中的线索\n\n```cmd\ngit clone https://github.com/golang/go.git\ncd go\ncode .\n```\n\n上来直接一个闪电三连码，用命令行打开我习惯的vscode开始看。\n\n通过搜索找到了`go get`和`go install`的源码，分别位于\n\n|命令|源码位置|\n|-|-|\n|go get|./go/internal/get/get.go|\n|go install|./go/internal/work/build.go|\n\n**为什么`go install`不是在install.go里？**根据我的观察，因为go install和go build的功能和实现都很接近，所以这两个命令的源码都在/go/internal/work/build.go。\n\n主要看看`get.go`的源码，里面有一个`runGet`方法，这是执行`go get`的入口方法，该方法中存在这样的调用链：\n`load.PackagesForBuild`->`PackagesAndErrors`->`ImportPaths`\n\n|方法名|源码位置|\n|-|-|\n|load.PackagesForBuild|.go/internal/load/pkg.go|\n|PackagesAndErrors|.go/internal/load/pkg.go|\n|ImportPaths|.go/internal/load/pkg.go|\n\n这个`ImportPaths`方法完整如下：\n\n```go\nfunc ImportPaths(args []string) []*search.Match {\n    if ModInit(); cfg.ModulesEnabled {\n        return ModImportPaths(args)\n    }\n    return search.ImportPaths(args)\n}\n```\n\n可一看到源码中关于`ModInit(); cfg.ModulesEnabled`是否成立有两种处理模式。\n\n#### 3.7 关键信息\n\n因为源码里对于`ModInit()`只是简单的`var ModInit func()`，没有方法体可以看到，也许是再别的地方进行了实现，我也没有深究。主要是看到了`cfg.ModulesEnabled`这个变量，直接想到了go module是否生效的问题，于是百度了`go module`并且看到了这篇文章`[go module 基本使用](https://www.cnblogs.com/chnmig/p/11806609.html)`，里面有这样一段话：\n\n> go在1.13版本默认是auto,~~代表 当项目在 GOPATH/src 外且项目根目录有 go.mod 文件时，开启 go module.也就是说,如果你不把代码放置在 GOPATH/src 下则默认使用 MODULE 管理.~~\n不好意思看错了,1.13+的版本判断开不开启MODULE的依据是根目录下有没有go.mod文件\n我们也可手动更改为 on(全部开启)/off(全部不开启)\n\n我恍然大悟，因为我`go get`的地方正好就是随便一个地方->没有在项目里->自然没有`go.mod`->也就没有开启`module`->`ModInit(); cfg.ModulesEnabled`不成立->`go get`源码进入了另一种处理方式->hugo源码中的`go.mod`没有生效，一切都解释的通了。\n\n#### 3.8 验证\n\n验证的方法也很简单，根据前文的判断关键，新建一个有`go.mod`的环境再执行一次`go get`就可以了。\n\n```cmd\nmkdir testgo\ncd testgo \ngo mod init xxx\ngo: creating new go.mod: module xxx\ngo get -v github.com/gohugoio/hugo\n```\n\n在有`go.mod`存在的环境下是可以安装成功的，也证明了前面的说法，至此一切都解决了。\n\n### 4. 结尾\n\n这次的问题也花了一整个下午的时间去排查，先是花了一些时间思考可能的原因，又花了很长时间去看源码，读源码真的花了很长很长的时间，一连看了几个小时直到头都有些晕了在起身去吃饭，吃完饭回来有精神了继续看了一会就发现问题了，可能在文章中就是简单的调用链路和几行关键代码，但是怎么在上千行的源码中找到这些关键信息远没有文章中的那么简单，首先是要看懂，然后是顺着调用链往下继续看懂，有时候还会误解然后找错方向找了很久……\n\n但结果还是非常好的，解决了自己的疑惑，更难能的是在源码里学到了几个很有意思很妙的写法，比如这两个：\n\n```go\n// 这个else if的顺序和作用域利用的很充分\nfunc CleanPatterns(patterns []string) []string {\n    // 省略\n    var out []string\n    for _, a := range patterns {\n        var p, v string\n        if build.IsLocalImport(a) || filepath.IsAbs(a) {\n            p = a\n        } else if i := strings.IndexByte(a, '@'); i < 0 {\n            p = a\n        } else {\n            p = a[:i]\n            v = a[i:]\n        }\n        // 省略\n    }\n    // 省略\n}\n```\n\n```go\n// 匿名函数+函数变量+递归+闭包的妙用\nfunc PackageList(roots []*Package) []*Package {\n    seen := map[*Package]bool{}\n    all := []*Package{}\n    var walk func(*Package)\n    walk = func(p *Package) {\n        if seen[p] {\n            return\n        }\n        seen[p] = true\n        for _, p1 := range p.Internal.Imports {\n            walk(p1)\n        }\n        all = append(all, p)\n    }\n    for _, root := range roots {\n        walk(root)\n    }\n    return all\n}\n```\n\n写的有点长了，但还是想完整的记录一下心路历程，折腾的过程还是很有意思的。\n","excerpt":"该文章的golang版本为 go version go1.14.5 darwin/amd64 心路历程 1. 报错 晚上本来想装个hugo玩玩，hugo提供了挺多安装方法比如最直接的二进制包安装、homebrew等包管理安装、docker，正好电脑里也有golang的环境，平时装go写的软件也很方便 go get…"},{"slug":"posts/code/homebrew-install","title":"使用homebrew安装你电脑上的所有软件吧","content":"---\ntitle: \"使用homebrew安装你电脑上的所有软件吧\"\ndate: 2020-12-08T21:42:54+08:00\ncategories: [\"code\"]\ntags: [\"homebrew\", \"macbook\", \"macos\"]\ndraft: false\n---\n\n最近需要重装 mac，想着能不能用 homebrew 统一安装所有软件，本来以为有些软件应该会缺失的，结果竟然几乎完全可以用 brew install，简单记录供日后参考。\n\n## 已尝试可安装软件\n\natom、datagrip、deno、discord、docker、emacs、golang、chrome、idea、网易邮箱大师（mailmaster）、网易云音乐、有道词典、micro、mos、mumble、nginx、node、openjdk8、openjdk11、postman、qq、qqmusic、rust-up、sogouinput、ssr、telegram、telnet、腾讯会议（tencent-meeting）、terminus、tree、unrar、vscode、wechat、wget、aliwangwang\n\n安装命令可以拉倒最底下查看\n\n## 已尝试失败软件\n\n随着尝试软件的增加，已经出现一些不能使用brew安装的软件了\n\n- 百度网盘，brew安装的是一个很老的叫百度同步盘的东西\n- wps，brew安装的是英文版，难用\n- zoom会议，brew没有\n\n## 安装 homebrew\n\n访问[homebrew 官网](https://brew.sh/)，复制脚本执行命令即可，这里给出命令，不过还是以官网为准。\n\n```bash\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\"\n```\n\n## 用 homebrew 安装所有软件\n\n### Chrome\n\n不多解释了，程序员必备浏览器\n\n```bash\nbrew cask install google-chrome\n```\n\n### 音乐播放器\n\n网易云音乐\n\n```bash\nbrew cask install neteasemusic\n```\n\nQQ 音乐\n\n```bash\nbrew cask install qqmusic\n```\n\n### 通讯工具\n\n微信\n\n```bash\nbrew cask install wechat\n```\n\nQQ\n\n```bash\nbrew cask install qq\n```\n\nmumble，这是一个开源的游戏语音工具，可以在自己的云服务器部署。\n\n```bash\nbrew cask install mumble\n```\n\n### 终端相关\n\nterminus，一个很漂亮的终端。\n\n```bash\nbrew cask install terminus\n```\n\noh-my-zsh，最好访问[官网](https://ohmyz.sh/)获取最新安装命令。\n\n```bash\nsh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n```\n\n### 网络相关\n\n测试 socket 代理必备客户端。\n\n```bash\nbrew cask install shadowsocksx-ng-r\n```\n\nNginx，高性能 Web 服务器。\n\n```bash\nbrew install nginx\n// 通过brew安装的nginx可以通过brew services管理\nbrew services start nginx\n```\n\n### 编程应用\n\nVSCode\n\n```bash\nbrew cask install visual-studio-code\n```\n\nPostman\n\n```bash\nbrew cask install postman\n```\n\nIDEA\n\n```bash\nbrew cask install intellij-idea\n```\n\n### 开发环境\n\nPython\n\n```bash\nmacOS自带python，无需安装。\n```\n\nJava，因为最新版 JDK8 需要付费，这里选择 AdoptOpenJDK。\n\n```bash\nbrew cask install adoptopenjdk8\n```\n\nGolang\n\n```bash\nbrew install golang\n```\n\nNode.js\n\n```bash\nbrew install node\n```\n\nDeno\n\n```bash\nbrew install deno\n```\n\nRust，根据官网的教程，需要先安装 rustup，再通过 rustup 安装 rust 工具链。\n\n```bash\nbrew install rustup-init\n// 安装完通过rustup-init命令执行安装脚本\nrustup-init\n```\n\nDocker，有了 Docker 就不用装 Mysql、Redis、MongoDB、Kafka、ZooKeeper 等服务了，直接起 Docker 容器。\n\n```bash\nbrew cask install docker\n```\n\n## 安装命令集合\n\n```bash\nbrew cask install atom\nbrew cask install datagrip\nbrew install deno\nbrew cask install discord\nbrew cask install docker\nbrew install emacs\nbrew install golang\nbrew cask install google-chrome\nbrew cask install intellij-idea\nbrew cask install mailmaster\nbrew install micro\nbrew cask install mos\nbrew cask install mumble\nbrew cask install neteasemusic\nbrew install nginx\nbrew services start nginx\nbrew install node\nbrew cask install adoptopenjdk8\nbrew install openjdk@11\nbrew cask install popo\nbrew cask install postman\nbrew cask install QQ\nbrew cask install qqmusic\nbrew install rustup-init\nbrew cask install sogouinput\nbrew cask install shadowsocksx-ng-r\nbrew cask install telegram\nbrew install telnet\nbrew cask install tencent-meeting\nbrew cask install terminus\nbrew install tree\nbrew install unrar\nbrew cask install visual-studio-code\nbrew cask install wechat\nbrew install wget\nbrew cask install youdaodict\nbrew cask install aliwangwang\n```\n","excerpt":"最近需要重装 mac，想着能不能用 homebrew 统一安装所有软件，本来以为有些软件应该会缺失的，结果竟然几乎完全可以用 brew install，简单记录供日后参考。 已尝试可安装软件 atom、datagrip、deno、discord、docker、emacs、golang、chrome、idea…"},{"slug":"posts/code/iris-chatroom-demo","title":"iris项目示例，基于AJAX的简易聊天室","content":"---\ntitle: \"iris项目示例，基于AJAX的简易聊天室\"\ndate: 2020-12-08T21:36:33+08:00\ncategories: [\"code\"]\ntags: [\"golang\", \"ajax\", \"chatroom\"]\ndraft: false\n---\n\n> 项目地址[https://github.com/JabinGP/demo-chatroom](https://github.com/JabinGP/demo-chatroom)，对你有帮助的话请多多star\n\ngo+iris+jwt+mysql+gorm+viper，iris项目实战简易聊天室，登录、注册、私聊、群聊。\n\n## 项目启动\n\n```cmd\ngit clone https://github.com/JabinGP/demo-chatroom.git\ncd demo-chatroom\n// 复制config.toml.example 为 config.toml 并填写数据库信息，或者可选修改端口号\ngo run demo-chatroom.go\n```\n\n默认为8888端口，启动后访问`http://localhost:8888`即可，或者访问演示地址`http://mike.jabingp.cn:8888`\n\n### 前端\n\n用了react，但是没用ui框架，很多的小细节上表现并不好，凑合着看吧，重点放在后端。\n\n聊天框设置了窗口自动滚动到底端，但是api是react提供的，发现在许多浏览器上并不兼容，使用chrome浏览器可以解决这个问题。\n\n注册后手动返回选择登陆，消息框里面的红色名称为公共发言，灰色名称为私聊发言、可以在红色的框里面指定接收者的名称，如果不指定的话，默认是公共发言，指定后只有对应的用户能看到信息。\n\n蓝色框内显示自己的用户名，点击即直接退出登录。\n\n### 后端\n\napi格式基于restful设计，登录功能使用jwt完成，许多接口需要登录状态，请求的时候需要携带JWT，具体请看[golang iris的jwt实践](https://segmentfault.com/a/1190000021187448)，另外便于测试，JWT签发有效时间只设置了20分钟，过期需要重新登录。\n\n|功能|请求方式|地址|\n|-|-|-|\n|获取登录token|POST|[http://localhost:8888/v1/login](http://localhost:8888/v1/login)|\n|查找用户|GET|[http://localhost:8888/v1/user](http://localhost:8888/v1/user)|\n|注册|POST|[http://localhost:8888/v1/user](http://localhost:8888/v1/user)|\n|用户自己修改信息|PUT|[http://localhost:8888/v1/user](http://localhost:8888/v1/user)|\n|用户发送信息|POST|[http://localhost:8888/v1/message](http://localhost:8888/v1/message)|\n|用户获取信息|GET|[http://localhost:8888/v1/message](http://localhost:8888/v1/message)|\n|用户获取token信息|GET|[http://localhost:8888/v1/token/info](http://localhost:8888/v1/token/info)|\n\n详细请求参数可以在[demo-chatroom的postman-api文档](https://documenter.getpostman.com/view/7019042/SWECVaGy?version=latest)里查看。\n\n或者查看源码，请求参数在`model/reqo`里面查看，响应参数可以在`model/reso`里查看\n\n## 前言\n\n聊天功能AJAX不是最好的选择，WebSocket比较好，但是被要求使用了AJAX所以没有选择后者。\n\n项目的前端比较简陋，因为只是作为demo使用。\n\n英语不是很好，代码注释用英语只是因为懒得切换输入法。\n\n第一次用go开发web项目，也是第一次用react写前端，由于前端没怎么注重项目结构（xjbx），就不放源码了，把项目编译后放在了assets文件夹下，可读性很差，但是可以和后端一起启动，不需要单独启动前端，比较方便查看效果。如果还有时间会考虑用原生写一个极简版的供大家参考原理。\n\n第一次用ORM操作数据库，感觉好难用，我还是宁愿手写sql，好多想要的效果翻半天文档都找不到解决方案，后期有机会考虑用sqlx重构。\n\n## 项目来源\n\n最近对Go比较有兴趣，又接到任务编写一个简易聊天室，发现目前iris的项目实践比较少，只有一些HelloWorld级别的示例，于是决定用Go来做，然后开源出来供大互相参考借鉴，当然项目结构如何设计完全基于我有限的开发经验，对于不合理的地方，请给出你宝贵的意见。\n\n## 项目要点\n\n这个项目有如下要求\n\n1. 基于AJAX\n2. 前端页面需要无刷新（自动更新数据）\n3. 登录功能\n4. 注册功能（要求用户有用户名、密码、性别、年龄、兴趣爱好）\n\n## 实现思路\n\n### 登陆功能\n\n登陆功能这次选用`JWT`来实现，`JWT`和`Session`各自的优劣就不再赘述。\n\n### 基于AJAX，且无刷新\n\n基于AJAX是所有前后端分离项目的必备，因此这个功能不过多讨论，这里重点在于无刷新，难点在哪？\n\n#### 用户操作需求\n\n用户的操作逻辑是，在聊天室里面发送数据，然后数据就被发出去，聊天界面要显示出自己发送的数据，以及要实时更新别人发出来的数据。\n\n#### 前端的操作逻辑\n\n前端和后端之间是通过AJAX来交流的，前端发送数据和后端发送数据可以表现为\n\n- 发送数据：前端将需要发送的数据以JSON格式携带在请求里，请求对于结构\n- 获取数据：前端请求后台获取消息的接口，获取最新消息\n\n这里有什么问题？问就在前端永远只能主动发起请求，而后端永远只能接受请求。这意味着最新的消息永远无法实时地从后端主动发送给前端，最新的消息只能先存放在后端，然后等待前端发起请求，后端才能返回数据。\n\n由于后端是没有能力主动推送消息给前端的，因此用户获取最新数据的解决方法是前端设置一个定时器`每隔一段比较短的时间就请求一次后台接口（轮询）`，这样就能不断更新数据。\n\n#### 后端的操作逻辑\n\n前端已经确定使用AJAX定时轮询后台接口来获取最新数据，为了数据实时性，轮询间隔会`小于1s`，这样又会带来另个问题，后端在如此频繁的请求下，一定不能每次都将所有数据都传输出去，一是数据大小导致的网路传输效率、流量成本问题，二是数据大小导致的前端判断新数据的效率问题，那么后端每次必须都返回前端还没有接收过的数据，而问题在于--后端怎么知道前端已经接收了哪些信息？\n\n这个就要利用到消息的`自增主键`，只需要前端每次请求的时候都携带上前端已经接收的`最后的消息的主键`，由于主键是不重复且自增的，我们可以很轻松的找出比该主键大的数据，也就是前端还没接收到的数据。\n\n## 项目技术栈\n\n- 语言\n  - Golang\n  - HTML\n  - CSS\n  - JavaScript\n\n- 框架\n  - Iris 后端框架\n  - React 前端框架\n  - Gorm 数据库ORM框架\n  - Viper 多类型配置文件读取支持\n\n- 数据存储\n  - Mysql 经典数据库\n\n- 技术\n  - JWT 签发登陆令牌\n  - AJAX 异步请求后端数据\n\n## 数据库设计结构\n\n> 由于使用了Gorm数据库ORM框架，以下表都是自动生成的，自带了`xxxxxx_at`字段\n\n基于如上的需求，设计了`users`和`messages`两个表\n\n### users\n\n关键字段\n\n- id\n- username\n- passwd\n- gender\n- age\n- interest\n\n数据库表结构\n\n| Field | Type | Null | Key | Default | Extra |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| id | int\\(10\\) unsigned | NO | PRI | NULL | auto\\_increment |\n| created\\_at | timestamp | YES |  | NULL |  |\n| updated\\_at | timestamp | YES |  | NULL |  |\n| deleted\\_at | timestamp | YES | MUL | NULL |  |\n| username | varchar\\(255\\) | YES |  | NULL |  |\n| passwd | varchar\\(255\\) | YES |  | NULL |  |\n| gender | bigint\\(20\\) | YES |  | NULL |  |\n| age | bigint\\(20\\) | YES |  | NULL |  |\n| interest | varchar\\(255\\) | YES |  | NULL |  |\n\n### messages\n\n关键字段\n\n- id\n- sender_id -> 对应消息发送者\n- receiver_id -> 对应消息接受者\n- content\n- send_time\n\n数据库表结构\n\n| Field | Type | Null | Key | Default | Extra |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| id | int\\(10\\) unsigned | NO | PRI | NULL | auto\\_increment |\n| created\\_at | timestamp | YES |  | NULL |  |\n| updated\\_at | timestamp | YES |  | NULL |  |\n| deleted\\_at | timestamp | YES | MUL | NULL |  |\n| sender\\_id | int\\(10\\) unsigned | YES |  | NULL |  |\n| receiver\\_id | int\\(10\\) unsigned | YES |  | NULL |  |\n| content | varchar\\(255\\) | YES |  | NULL |  |\n| send\\_time | timestamp | YES |  | NULL |  |\n\n## 项目结构\n\n> 以下结构出于个人经验，有不当之处请给出宝贵意见\n\n- route 路由层，负责将\"\\xxx\\xxx\"请求映射到对应的函数\n- middleware 中间件层，可以在执行函数前后进行拦截并处理，如登陆拦截\n- controller 控制层，存放与\"\\xxx\\xxx\"请求对应的函数，根据请求，调用业务层，并将数据进行格式封装返回\n- service 业务层，调用持久层完成业务逻辑\n- dao 持久层，可以理解为sql执行到函数执行的封装，由于使用了ORM，本项目没有dao层目录\n- database 提供数据库连接\n- model 定义一系列结构体\n  - pojo 业务逻辑实体，如User，Message\n  - reqo 请求数据实体，对应controller中的每个方法\n  - reso 响应数据实体，对应controller中的每个方法\n- config 读取配置，并提供单实例的配置文件实体供外访问\n- tool 工具层\n- assets 静态资源目录，存放静态资源（前端文件）\n\n### pojo、reqo、reso都是什么\n\n- pojo\n\n  很好理解，就是数据库对应的实体，但不要求与数据库字段一一对应\n\n- reqo(request object)、reso(response object)\n\n  不同接口请求的时候，可以携带的参数以及响应的数据也不同，所以为每一个接口设计一个对应的请求实体和响应实体\n\n### controller、service、dao到底有什么区别\n\n> 以下为个人理解\n\n- Controller\n\n  主要职责是，接受请求的请求参数，转换为reqo，进行简单的请求参数验证（我个人的定义与数据库无关的验证，如非空、非零），调用Service层的函数获取pojo结果，并将pojo结果转换封装为reso返回。\n\n- Service\n\n  主要职责是，对Dao层的接口进一步封装，提供通用的接口给Controller调用，返回数据可以是pojo，在Service内需要进行数据的验证，如（新增用户，校验用户名是否重复）。\n\n- Dao\n\n  这里基本上一个方法直接对应一条sql语句，不做任何的验证，认为接收到的数据是可靠的（已经经过了Controller和Service两层的参数验证了），返回数据可以是pojo。\n\n> 项目地址[https://github.com/JabinGP/demo-chatroom](https://github.com/JabinGP/demo-chatroom)，对你有帮助的话请多多star！\n","excerpt":"项目地址 https://github.com/JabinGP/demo-chatroom ，对你有帮助的话请多多star go+iris+jwt+mysql+gorm+viper，iris项目实战简易聊天室，登录、注册、私聊、群聊。 项目启动 默认为8888端口，启动后访问 http://localhost:888…"},{"slug":"posts/code/iris-jwt","title":"iris的jwt实践，获取jwt、携带jwt、验证jwt、设置过期时间、自定义错误处理函数、格式化错误返回","content":"---\ntitle: \"iris的jwt实践，获取jwt、携带jwt、验证jwt、设置过期时间、自定义错误处理函数、格式化错误返回\"\ndate: 2020-12-08T21:21:30+08:00\ncategories: [\"code\"]\ntags: [\"golang\", \"jwt\", \"iris\"]\ndraft: false\n---\n\n> 由于jwt原理已经有很多文章提及过了，这里不再赘述，本文主要介绍jwt在iris中的实践，文章的最后会给出完整代码，可以运行起来边测试边看。\n> 如果文章对你有帮助，点个赞或者留下评论将会是对我的极大鼓励！\n\n## jwt使用方向\n\n本文将jwt用于登录功能，如果是其他功能需求其实也类似，可以触类旁通。\n\n## iris中jwt的使用思想\n\niris基于中间件思想设计，对于一些重复性的操作，可以通过注册中间件来完成。对于登录功能，我们自然不希望每个api中手动判断是否过期，是否合法等，因为我们需要一个jwt中间件来完成这些操作。\n\n## 获取jwt中间件\n\n这是一个iris官方提供的jwt中间件：\n\n```go\nimport \"github.com/iris-contrib/middleware/jwt\"\n```\n\n用法如下：\n\n```go\nj := jwt.New(jwt.Config{\n    // Extractor属性可以选择从什么地方获取jwt进行验证，默认从http请求的header中的Authorization字段提取，也可指定为请求参数中的某个字段\n\n    // 从请求参数token中提取\n    // Extractor: jwt.FromParameter(\"token\"),\n\n    // 从请求头的Authorization字段中提取，这个是默认值\n    Extractor: jwt.FromAuthHeader,\n\n    // 设置一个函数返回秘钥，关键在于return []byte(\"这里设置秘钥\")\n    ValidationKeyGetter: func(token *jwt.Token) (interface{}, error) {\n      return []byte(\"My Secret\"), nil\n    },\n\n    // 设置一个加密方法\n    SigningMethod: jwt.SigningMethodHS256,\n  })\n```\n\n`jwt.Config`中还有一些可以设置的参数，但是便于理解，以以上三个参数作为演示\n\n## 使用jwt中间件\n\n由于并非所有接口都需要设置登录拦截，所以将中间件用于路由，或者路由组是比较符合业务需求的做法\n\n先给出两个接口：\n\n1. \"/getJWT\"：生成jwt并返回\n2. \"/showHello\"：没有任何限制，访问就输出\"Hello Iris JWT\"\n\n```go\npackage main\n\nimport (\n  \"github.com/kataras/iris/v12\"\n\n  \"github.com/iris-contrib/middleware/jwt\"\n)\n\nfunc main() {\n  app := iris.New()\n\n  app.Get(\"/getJWT\", func(ctx iris.Context) {\n    // 往jwt中写入了一对值\n    token := jwt.NewTokenWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\n      \"foo\": \"bar\",\n    })\n\n    // 签名生成jwt字符串\n    tokenString, _ := token.SignedString([]byte(\"My Secret\"))\n\n    // 返回\n    ctx.JSON(tokenString)\n  })\n\n  app.Get(\"/showHello\", func(ctx iris.Context) {\n    ctx.JSON(\"Hello Iris JWT\")\n  })\n\n  app.Run(iris.Addr(\":8080\"))\n}\n\n```\n\n访问[http://localhost:8080/getJWT](http://localhost:8080/getJWT)返回一串类似这样的字符串\n\n```json\n\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIifQ.4aQan-XvJBjDUDbCVnuh2P_xy54b2aRKKsgKcHUa8uw\"\n```\n\n访问[http://localhost:8080/showHello](http://localhost:8080/showHello)返回\n\n```json\n\"Hello Iris JWT\"\n```\n\n现在我们要对`showHello`接口加上jwt验证，需要用到上一小节的jwt中间件\n\n```go\npackage main\n\nimport (\n  \"github.com/kataras/iris/v12\"\n\n  \"github.com/iris-contrib/middleware/jwt\"\n)\n\nfunc main() {\n  app := iris.New()\n\n  j := jwt.New(jwt.Config{\n    // Extractor属性可以选择从什么地方获取jwt进行验证，默认从http请求的header中的Authorization字段提取，也可指定为请求参数中的某个字段\n\n    // 从请求参数token中提取\n    // Extractor: jwt.FromParameter(\"token\"),\n\n    // 从请求头的Authorization字段中提取，这个是默认值\n    Extractor: jwt.FromAuthHeader,\n\n    // 设置一个函数返回秘钥，关键在于return []byte(\"这里设置秘钥\")\n    ValidationKeyGetter: func(token *jwt.Token) (interface{}, error) {\n      return []byte(\"My Secret\"), nil\n    },\n\n    // 设置一个加密方法\n    SigningMethod: jwt.SigningMethodHS256,\n  })\n\n  app.Get(\"/getJWT\", func(ctx iris.Context) {\n    // 往jwt中写入了一对值\n    token := jwt.NewTokenWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\n      \"foo\": \"bar\",\n    })\n\n    // 使用设置的秘钥，签名生成jwt字符串\n    tokenString, _ := token.SignedString([]byte(\"My Secret\"))\n\n    // 返回\n    ctx.JSON(tokenString)\n  })\n\n  // 注意这里加了j.Serve作为路由的中间件\n  app.Get(\"/showHello\", j.Serve, func(ctx iris.Context) {\n    ctx.JSON(\"Hello Iris JWT\")\n  })\n\n  app.Run(iris.Addr(\":8080\"))\n}\n```\n\n访问[http://localhost:8080/showHello](http://localhost:8080/showHello)返回\n\n```cmd\nrequired authorization token not found\n```\n\n由于开启了jwt认证，你可能会想到，给`Header`中加入一个字段`Authorization`，然后值为刚刚`getJWT`接口返回的字符串就可以成功通过这个验证了。\n\n### 测试JWT验证\n\n在`Postman`（或者其他测试工具，都一样）中请求的`Headers`中加入一对值\n\n|kEY|VALUE|\n|-|-|\n|Authorization|eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIifQ.4aQan-XvJBjDUDbCVnuh2P_xy54b2aRKKsgKcHUa8uw|\n\n访问[http://localhost:8080/showHello](http://localhost:8080/showHello)返回\n\n```cmd\nAuthorization header format must be Bearer {token}\n```\n\n可能你会纳闷，这个`Authorization header format must be Bearer {token}`是什么意思？按逻辑来讲，我们的做法应该是没有错的。确实，就两次请求的变化来看，`Headers`加入的`Authorization`的的确确被识别到了，但是似乎还有些小问题，根据提示，是格式上还有些出入。\n\n在`Postman`（或者其他测试工具，都一样）中请求的`Headers`中更改`Authorization`值为\n\n|kEY|VALUE|\n|-|-|\n|Authorization|JWT eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIifQ.4aQan-XvJBjDUDbCVnuh2P_xy54b2aRKKsgKcHUa8uw|\n\n这样似乎符合`Bearer {token}`格式了，访问[http://localhost:8080/showHello](http://localhost:8080/showHello)返回\n\n```json\nAuthorization header format must be Bearer {token}\n```\n\n说明格式还是不对。\n\n继续修改`Headers`\n\n|kEY|VALUE|\n|-|-|\n|Authorization|Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIifQ.4aQan-XvJBjDUDbCVnuh2P_xy54b2aRKKsgKcHUa8uw|\n\n访问[http://localhost:8080/showHello](http://localhost:8080/showHello)返回\n\n```json\n\"Hello Iris JWT\"\n```\n\n这次终于返回`\"Hello Iris JWT\"`了，说实话这个格式要求和这个提示有点坑。\n\n### JWT中间件做了什么\n\n可以看到，我们的`/showHello`接口纯粹就是返回`\"Hello Iris JWT\"`，没有做任何和JWT有关的操作，但是由于我们在路由上使用了JWT中间件，我们的`/showHello`接口具有了`自动JWT验证`的功能，这是JWT中间件在执行我们的接口代码之前，自动帮我们做的。\n\n修改`Headers`中的`Authorization`的值，偷偷把最后一个字符改成其他，看看接口是否能够验证出阿里这是一个假的jwt\n\n|kEY|VALUE|\n|-|-|\n|Authorization（真）|Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIifQ.4aQan-XvJBjDUDbCVnuh2P_xy54b2aRKKsgKcHUa8uw|\n|Authorization（假）|Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIifQ.4aQan-XvJBjDUDbCVnuh2P_xy54b2aRKKsgKcHUa8uu|\n\n访问[http://localhost:8080/showHello](http://localhost:8080/showHello)返回\n\n```json\nsignature is invalid\n```\n\n可见不合法的jwt是无法通过验证的。\n\n### 获取JWT中的值\n\nJWT中间件在验证失败的时候，接口中的代码不会被执行，请求在JWT验证的时候就被响应`signature is invalid`并结束。\n而当JWT中间件验证成功的时候，我们则可以在接口中获取到JWT的信息，我们添加一个接口`/showJWT`，来输出JWT的结构：\n\n```go\napp.Get(\"/showJWT\", j.Serve, func(ctx iris.Context) {\n  jwtInfo := ctx.Values().Get(\"jwt\").(*jwt.Token)\n  ctx.JSON(jwtInfo)\n})\n```\n\n同样需要设置`Headers`带上jwt\n\n|kEY|VALUE|\n|-|-|\n|Authorization|Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIifQ.4aQan-XvJBjDUDbCVnuh2P_xy54b2aRKKsgKcHUa8uw|\n\n访问[http://localhost:8080/showJWT](http://localhost:8080/showJWT)返回\n\n```json\n{\n    \"Raw\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIifQ.4aQan-XvJBjDUDbCVnuh2P_xy54b2aRKKsgKcHUa8uw\",\n    \"Method\": {\n        \"Name\": \"HS256\",\n        \"Hash\": 5\n    },\n    \"Header\": {\n        \"alg\": \"HS256\",\n        \"typ\": \"JWT\"\n    },\n    \"Claims\": {\n        \"foo\": \"bar\"\n    },\n    \"Signature\": \"4aQan-XvJBjDUDbCVnuh2P_xy54b2aRKKsgKcHUa8uw\",\n    \"Valid\": true\n}\n```\n\n可以看到`Claims`里面就有我们签发jwt的时候写入的数据了，如果想要在接口中拿到：\n\n```go\napp.Get(\"/showJWTFoo\", j.Serve, func(ctx iris.Context) {\n  jwtInfo := ctx.Values().Get(\"jwt\").(*jwt.Token)\n  foo := jwtInfo.Claims.(jwt.MapClaims)[\"foo\"].(string)\n  ctx.JSON(foo)\n})\n```\n\n设置`Headers`带上jwt\n\n|kEY|VALUE|\n|-|-|\n|Authorization|Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIifQ.4aQan-XvJBjDUDbCVnuh2P_xy54b2aRKKsgKcHUa8uw|\n\n访问[http://localhost:8080/showJWTFoo](http://localhost:8080/showJWTFoo)返回\n\n```json\n\"bar\"\n```\n\n### 设置过期时间\n\n由于jwt签发出去之后，后端并不存储，所以相当于后端并不能管理签发出去的jwt，这种情况下后端自然不能让签发出去的jwt永久有效，需要根据需求设置一个过期时间。\n\n新增一个获取JWT的接口，这次在`Claims`中写入更多的数据：\n\n```go\napp.Get(\"/getJWTWithExp\", func(ctx iris.Context) {\n  token := jwt.NewTokenWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\n    // 根据需求，可以存一些必要的数据\n    \"userName\": \"JabinGP\",\n    \"userId\":   \"1\",\n    \"admin\":    true,\n\n    // 签发人\n    \"iss\": \"iris\",\n    // 签发时间\n    \"iat\": time.Now().Unix(),\n    // 设定过期时间，便于测试，设置1分钟过期\n    \"exp\": time.Now().Add(1 * time.Minute * time.Duration(1)).Unix(),\n  })\n\n  // 使用设置的秘钥，签名生成jwt字符串\n  tokenString, _ := token.SignedString([]byte(\"My Secret\"))\n\n  // 返回\n  ctx.JSON(tokenString)\n})\n```\n\n请求[http://localhost:8080/getJWTWithExp](http://localhost:8080/getJWTWithExp)返回\n\n```json\n\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiZXhwIjoxNTc1Mzc5OTk0LCJpYXQiOjE1NzUzNzk5MzQsImlzcyI6ImlyaXMiLCJ1c2VySWQiOiIxIiwidXNlck5hbWUiOiJKYWJpbkdQIn0.AMFZNbtERLHzKAR9z7oF_0QeNoARKr4dkjocNbVsWgg\"\n```\n\n设置`Headers`带上新的jwt\n\n|kEY|VALUE|\n|-|-|\n|Authorization|Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiZXhwIjoxNTc1Mzc5OTk0LCJpYXQiOjE1NzUzNzk5MzQsImlzcyI6ImlyaXMiLCJ1c2VySWQiOiIxIiwidXNlck5hbWUiOiJKYWJpbkdQIn0.AMFZNbtERLHzKAR9z7oF_0QeNoARKr4dkjocNbVsWgg|\n\n访问[localhost:8080/showJWT](localhost:8080/showJWT)返回\n\n```json\n{\n    \"Raw\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiZXhwIjoxNTc1Mzc5OTk0LCJpYXQiOjE1NzUzNzk5MzQsImlzcyI6ImlyaXMiLCJ1c2VySWQiOiIxIiwidXNlck5hbWUiOiJKYWJpbkdQIn0.AMFZNbtERLHzKAR9z7oF_0QeNoARKr4dkjocNbVsWgg\",\n    \"Method\": {\n        \"Name\": \"HS256\",\n        \"Hash\": 5\n    },\n    \"Header\": {\n        \"alg\": \"HS256\",\n        \"typ\": \"JWT\"\n    },\n    \"Claims\": {\n        \"admin\": true,\n        \"exp\": 1575379994,\n        \"iat\": 1575379934,\n        \"iss\": \"iris\",\n        \"userId\": \"1\",\n        \"userName\": \"JabinGP\"\n    },\n    \"Signature\": \"AMFZNbtERLHzKAR9z7oF_0QeNoARKr4dkjocNbVsWgg\",\n    \"Valid\": true\n}\n```\n\n隔一分钟后，再次请求[localhost:8080/showJWT](localhost:8080/showJWT)返回\n\n```json\nToken is expired\n```\n\n说明过期时间设置生效。\n\n### 设置错误返回格式\n\n由于JWT中间件在检验jwt发现不合法时，会自动响应返回错误信息并结束请求，如上所示，错误都是一句话，这样的错误对于前端来说非常不友好，前端更希望能通过一个状态码来判断请求是否顺利。\n\n首先定义一个响应数据的模板：\n\n```go\n// ResModel 返回数据模板\ntype ResModel struct {\n  Code string      `json:\"code\"`\n  Msg  string      `json:\"msg\"`\n  Data interface{} `json:\"data\"`\n}\n```\n\n获取一个新的中间件，与之前不同的是自定义了错误处理函数（扒了源码改的）:\n\n注意引入的context是iris包下的，否则无法符合错误处理函数的定义。\n\n```go\nimport \"github.com/kataras/iris/v12/context\"\n```\n\n```go\n// j2 对比 j 添加了错误处理函数\nj2 := jwt.New(jwt.Config{\n  // 注意，新增了一个错误处理函数\n  ErrorHandler: func(ctx context.Context, err error) {\n    if err == nil {\n      return\n    }\n\n    ctx.StopExecution()\n    ctx.StatusCode(iris.StatusUnauthorized)\n    ctx.JSON(ResModel{\n      Code: \"501\",\n      Msg:  err.Error(),\n    })\n  },\n  // 设置一个函数返回秘钥，关键在于return []byte(\"这里设置秘钥\")\n  ValidationKeyGetter: func(token *jwt.Token) (interface{}, error) {\n    return []byte(\"My Secret\"), nil\n  },\n\n  // 设置一个加密方法\n  SigningMethod: jwt.SigningMethodHS256,\n})\n```\n\n在一个新的接口上应用新的`j2`中间件\n\n```go\napp.Get(\"/showJWTErrWithFormat\", j2.Serve, func(ctx iris.Context) {\n  jwtInfo := ctx.Values().Get(\"jwt\").(*jwt.Token)\n  ctx.JSON(jwtInfo)\n})\n```\n\n设置`Headers`带上一个过期的jwt\n\n|kEY|VALUE|\n|-|-|\n|Authorization|Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiZXhwIjoxNTc1Mzc5OTk0LCJpYXQiOjE1NzUzNzk5MzQsImlzcyI6ImlyaXMiLCJ1c2VySWQiOiIxIiwidXNlck5hbWUiOiJKYWJpbkdQIn0.AMFZNbtERLHzKAR9z7oF_0QeNoARKr4dkjocNbVsWgg|\n\n访问[localhost:8080/showJWT](localhost:8080/showJWT)返回\n\n```json\n{\n    \"code\": \"501\",\n    \"msg\": \"Token is expired\",\n    \"data\": null\n}\n```\n\n篡改`Headers`中`Authorization`的值，把最后一个字符改成其他的：`g`->`o`\n\n|kEY|VALUE|\n|-|-|\n|Authorization|Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiZXhwIjoxNTc1Mzc5OTk0LCJpYXQiOjE1NzUzNzk5MzQsImlzcyI6ImlyaXMiLCJ1c2VySWQiOiIxIiwidXNlck5hbWUiOiJKYWJpbkdQIn0.AMFZNbtERLHzKAR9z7oF_0QeNoARKr4dkjocNbVsWgo|\n\n访问[localhost:8080/showJWT](localhost:8080/showJWT)返回\n\n```json\n{\n    \"code\": \"501\",\n    \"msg\": \"signature is invalid\",\n    \"data\": null\n}\n```\n\n至此，jwt基本符合使用需求了，最后附上完整的代码。\n\n## 完整代码\n\n> 如果文章对你有帮助，点个赞或者留下评论将会是对我的极大鼓励！\n\n```go\npackage main\n\nimport (\n  \"time\"\n\n  \"github.com/kataras/iris/v12\"\n\n  \"github.com/iris-contrib/middleware/jwt\"\n  \"github.com/kataras/iris/v12/context\"\n)\n\n// ResModel 返回数据模板\ntype ResModel struct {\n  Code string      `json:\"code\"`\n  Msg  string      `json:\"msg\"`\n  Data interface{} `json:\"data\"`\n}\n\nfunc main() {\n  app := iris.New()\n\n  j := jwt.New(jwt.Config{\n    // Extractor属性可以选择从什么地方获取jwt进行验证，默认从http请求的header中的Authorization字段提取，也可指定为请求参数中的某个字段\n\n    // 从请求参数token中提取\n    // Extractor: jwt.FromParameter(\"token\"),\n\n    // 从请求头的Authorization字段中提取，这个是默认值\n    Extractor: jwt.FromAuthHeader,\n\n    // 设置一个函数返回秘钥，关键在于return []byte(\"这里设置秘钥\")\n    ValidationKeyGetter: func(token *jwt.Token) (interface{}, error) {\n      return []byte(\"My Secret\"), nil\n    },\n\n    // 设置一个加密方法\n    SigningMethod: jwt.SigningMethodHS256,\n  })\n\n  // j2 对比 j 添加了错误处理函数\n  j2 := jwt.New(jwt.Config{\n    // 注意，新增了一个错误处理函数\n    ErrorHandler: func(ctx context.Context, err error) {\n      if err == nil {\n        return\n      }\n\n      ctx.StopExecution()\n      ctx.StatusCode(iris.StatusUnauthorized)\n      ctx.JSON(ResModel{\n        Code: \"501\",\n        Msg:  err.Error(),\n      })\n    },\n    // 设置一个函数返回秘钥，关键在于return []byte(\"这里设置秘钥\")\n    ValidationKeyGetter: func(token *jwt.Token) (interface{}, error) {\n      return []byte(\"My Secret\"), nil\n    },\n\n    // 设置一个加密方法\n    SigningMethod: jwt.SigningMethodHS256,\n  })\n\n  app.Get(\"/getJWT\", func(ctx iris.Context) {\n    // 往jwt中写入了一对值\n    token := jwt.NewTokenWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\n      \"foo\": \"bar\",\n    })\n\n    // 使用设置的秘钥，签名生成jwt字符串\n    tokenString, _ := token.SignedString([]byte(\"My Secret\"))\n\n    // 返回\n    ctx.JSON(tokenString)\n  })\n  app.Get(\"/getJWTWithExp\", func(ctx iris.Context) {\n    token := jwt.NewTokenWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\n      // 根据需求，可以存一些必要的数据\n      \"userName\": \"JabinGP\",\n      \"userId\":   \"1\",\n      \"admin\":    true,\n\n      // 签发人\n      \"iss\": \"iris\",\n      // 签发时间\n      \"iat\": time.Now().Unix(),\n      // 设定过期时间，便于测试，设置1分钟过期\n      \"exp\": time.Now().Add(1 * time.Minute * time.Duration(1)).Unix(),\n    })\n\n    // 使用设置的秘钥，签名生成jwt字符串\n    tokenString, _ := token.SignedString([]byte(\"My Secret\"))\n\n    // 返回\n    ctx.JSON(tokenString)\n  })\n\n  app.Get(\"/showHello\", j.Serve, func(ctx iris.Context) {\n    ctx.JSON(\"Hello Iris JWT\")\n  })\n\n  app.Get(\"/showJWT\", j.Serve, func(ctx iris.Context) {\n    jwtInfo := ctx.Values().Get(\"jwt\").(*jwt.Token)\n    ctx.JSON(jwtInfo)\n  })\n\n  app.Get(\"/showJWTFoo\", j.Serve, func(ctx iris.Context) {\n    jwtInfo := ctx.Values().Get(\"jwt\").(*jwt.Token)\n    foo := jwtInfo.Claims.(jwt.MapClaims)[\"foo\"].(string)\n    ctx.JSON(foo)\n  })\n\n  app.Get(\"/showJWTErrWithFormat\", j2.Serve, func(ctx iris.Context) {\n    jwtInfo := ctx.Values().Get(\"jwt\").(*jwt.Token)\n    ctx.JSON(jwtInfo)\n  })\n\n  app.Run(iris.Addr(\":8080\"))\n}\n```\n","excerpt":"由于jwt原理已经有很多文章提及过了，这里不再赘述，本文主要介绍jwt在iris中的实践，文章的最后会给出完整代码，可以运行起来边测试边看。\n如果文章对你有帮助，点个赞或者留下评论将会是对我的极大鼓励！ jwt使用方向 本文将jwt用于登录功能，如果是其他功能需求其实也类似，可以触类旁通。 iris中jwt…"},{"slug":"posts/code/macos-docker-install-kafka","title":"macOS下使用docker安装kafka、遇到的坑与解决方案。","content":"---\ntitle: \"macOS下使用docker安装kafka、遇到的坑与解决方案。\"\ndate: 2020-12-08T21:39:49+08:00\ncategories: [\"code\"]\ntags: [\"macos\", \"kafka\", \"zookeeper\", \"docker\"]\ndraft: false\n---\n\n由于`kafka`依赖`zookeeper`，因此需要使用 docker 同时安装`zookeeper`和 `kafka`。\n\n坑：由于 macOS 的 docker 底层实现的不同，网上的很多教程放在 macOS 中并不能成功运行，主要原因是 macOS 的 docker 在容器和宿主之间无法通过 ip 直接通信。因此在安装的时候需要特殊注意与 ip 相关的设置，当容器需要访问宿主ip时，需要使用`docker.for.mac.host.internal`或者`host.docker.internal`代替。\n\n## 拉取镜像\n\n```cmd\ndocker pull wurstmeister/zookeeper\ndocker pull wurstmeister/kafka\n```\n\n## 启动容器\n\n### 启动 zookeeper\n\n```cmd\ndocker run -d --name zookeeper -p 2181:2181 wurstmeister/zookeeper\n```\n\n- `-d` 参数设置后台运行\n- `--name zookeeper` 参数指定容器别名\n- `-p 2181:2181` 参数绑定容器端口到宿主端口\n\n### 启动 kafka\n\n注意，**kafka 依赖 zookeeper**，启动 kafka 前需要先启动 zookeeper。\n\n以下配置默认 kafka 端口配置在 **9092** 端口。\n\n```cmd\ndocker run -d --name kafka -p 9092:9092 -e KAFKA_BROKER_ID=0 -e KAFKA_ZOOKEEPER_CONNECT={host-ip}:{zookeeper-port}/kafka -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://{host-ip}:9092 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 wurstmeister/kafka\n```\n\n`-d` 参数指定容器后台运行\n\n`--name kafka` 参数指定容器别名\n\n`-e` 参数可以设置 docker 容器内环境变量，每个变量的解释：\n\n- `KAFKA_BROKER_ID=0`\n  在 kafka 集群中，每个 kafka 都有一个 BROKER_ID 来区分自己\n- `KAFKA_ZOOKEEPER_CONNECT={host-ip}:{zookeeper-port}/kafka`\n  配置 zookeeper 管理 kafka 的路径\n- `KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://{host-ip}:9092`\n  把 kafka 的地址端口注册给 zookeeper\n- `KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092`\n  kafka 监听地址\n\n比如我的电脑是 mac，在 host-ip 这块就不能填本机 ip（windows 和 linux 可以），需要填`docker.for.mac.host.internal`，zookeeper 端口启动在**2181**，kafka 即将启动在**9092**，那么我的命令是这样的`docker run -d --name kafka -p 9092:9092 -e KAFKA_BROKER_ID=0 -e KAFKA_ZOOKEEPER_CONNECT=docker.for.mac.host.internal:2181/kafka -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://docker.for.mac.host.internal:9092 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 wurstmeister/kafka`\n\n## 测试功能是否正常\n\n### 测试 kafka 生产与消费\n\n#### 进入 kafka 容器\n\n```cmd\ndocker exec -it kafka bash\n```\n\n#### 进入 kafka 容器中的脚本目录\n\n注意，此时应该已经进入到了容器中的`bash`。\n\n进入 kafka 的脚本目录，其中`kafka_2.12-2.5.0`可能会随着版本而变化数字。\n\n```cmd\ncd /opt/kafka_2.12-2.5.0/bin\n```\n\n通过 ls 可以看到许多的.sh 脚本\n\n```cmd\nbash-4.4# ls\nconnect-distributed.sh               kafka-delete-records.sh              kafka-server-stop.sh\nconnect-mirror-maker.sh              kafka-dump-log.sh                    kafka-streams-application-reset.sh\nconnect-standalone.sh                kafka-leader-election.sh             kafka-topics.sh\nkafka-acls.sh                        kafka-log-dirs.sh                    kafka-verifiable-consumer.sh\nkafka-broker-api-versions.sh         kafka-mirror-maker.sh                kafka-verifiable-producer.sh\nkafka-configs.sh                     kafka-preferred-replica-election.sh  trogdor.sh\nkafka-console-consumer.sh            kafka-producer-perf-test.sh          windows\nkafka-console-producer.sh            kafka-reassign-partitions.sh         zookeeper-security-migration.sh\nkafka-consumer-groups.sh             kafka-replica-verification.sh        zookeeper-server-start.sh\nkafka-consumer-perf-test.sh          kafka-run-class.sh                   zookeeper-server-stop.sh\nkafka-delegation-tokens.sh           kafka-server-start.sh                zookeeper-shell.sh\nbash-4.4#\n```\n\n#### 测试 kafka 生产者和消费者\n\n##### 启动 kafka 生产者\n\n运行 kafka 生产者发送消息\n\n```cmd\n./kafka-console-producer.sh --broker-list localhost:9092 --topic first-topic\n```\n\n看到出现了个对话提示的小`>`就可以发送消息了，不过不要着急，先把消费者启动了。\n\n##### 启动 kafka 消费者\n\n另起一个终端，进入 kafka 容器，进入`/opt/kafka_2.12-2.5.0/bin`目录，运行 kafka 消费者接收消息\n\n```cmd\n./kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic first-topic --from-beginning\n```\n\n##### 测试发送和接收消息\n\n在生产者中发送`Hello`，消费者中应该能够收到`Hello`。\n\n生产者\n\n```cmd\njabin@jabindeiMac ~/code/tmp » docker exec -it kafka bash\nbash-4.4# cd /opt/kafka_2.12-2.5.0/bin/\nbash-4.4# ./kafka-console-producer.sh --broker-list localhost:9092 --topic first-topic\n>Hello\n>\n```\n\n消费者\n\n```cmd\njabin@jabindeiMac ~/code/tmp » docker exec -it kafka bash\nbash-4.4# cd /opt/kafka_2.12-2.5.0/bin/\nbash-4.4# ./kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic first-topic --from-beginning\nHello\n```\n\n## 参考文章\n\n[https://www.jianshu.com/p/e8c29cba9fae](https://www.jianshu.com/p/e8c29cba9fae)\n[https://docs.docker.com/docker-for-mac/networking/](https://docs.docker.com/docker-for-mac/networking/)\n[https://yuanmomo.net/2019/06/13/docker-network/](https://yuanmomo.net/2019/06/13/docker-network/)\n[https://www.jianshu.com/p/052f9c6ca664](https://www.jianshu.com/p/052f9c6ca664)\n","excerpt":"由于 kafka 依赖 zookeeper ，因此需要使用 docker 同时安装 zookeeper 和  kafka 。 坑：由于 macOS 的 docker 底层实现的不同，网上的很多教程放在 macOS 中并不能成功运行，主要原因是 macOS 的 docker 在容器和宿主之间无法通过 ip…"},{"slug":"posts/code/mini-program-music","title":"在微信小程序使用播放音乐的方法，以及微信小程序播放背景音乐失败的解决方案汇总","content":"---\ntitle: \"在微信小程序使用播放音乐的方法，以及微信小程序播放背景音乐失败的解决方案汇总\"\ndate: 2020-12-08T20:08:59+08:00\ncategories: [\"code\"]\ntags: [\"javascript\", \"小程序\", \"网易云音乐\", \"音乐外链\"]\ndraft: false\n---\n\n>项目要做一个可以为日记添加音乐的小程序，所以要用到音乐api，参考了一些文章后我们封装了一个qq音乐api库（完成了动态token获取，音乐搜索，音乐专辑图片，音乐名称，歌手名称，播放），有需要的可以到Github自提。  \n\n小程序qq音乐api库Gihub地址[https://github.com/FisherWY/QQMusicPlugin](https://github.com/FisherWY/QQMusicPlugin)，里面有简单的教程，如果开发工具不勾选ES6转ES5的话，则可以不需要里面的es6-promise这个js文件，并把`var Promise = require('./es6-promise.min.js')`在qqMusicTools.js中去掉。\n\n### 播放背景音乐失败的解决方案  \n\n1. 没有为音乐设置title\n    解决方案：在设置背景音乐的时候设置title:\"随便设置点东西\"\n\n2. 请求的url中带有中文路径\n    使用encodeURI(\"xxxxxx\")转码\n\n3. 手机设置了静音模式\n\n4. 一个非常奇葩的问题（翻遍了互联网都没找到解决方案，怀疑是官方的bug了）\n    android端（移动数据、WiFi、热点一切正常），电脑模拟器（开WiFi，3G各种模式都正常）都可以正常播放，iOS使用WiFi时正常播放，iOS使用移动数据、热点的时候无法播放，报错如下：\n\n    ```javascript\n    errCode:10002\n    errMsg:\"playerErrCode:6, systemErrCode:403, domain:com.tencent.KSAudioPlayer.HTTP, description:未能完成操作。（“com.tencent.KSAudioPlayer.HTTP”错误 403。）\"\n    src:\"http://ws.stream.qqmusic.qq.com/C400002WqezQ4dmIeT.m4a?guid=126548448&vkey=0E12BA0C521F05EF0103E99180DC5C50CA0E942E3183546F5D186F3E6F20F161E9EB0DCEA038F0A9A578E2DFAEBF434AF48521DA440A7EFF&fromtag=0\"\n    ```\n\n    ~~暂时没有找到解决方案，但是问题只在qq音乐api上出现，使用网易云完全正常。下一步准备使用网易云api代替qq音乐api~~。已经开发新的网易云api代替qq音乐api了，需要的可以看看这个项目：[为微信小程序开发的网易云音乐api库](https://github.com/JabinGP/NetEaseCloudMusicApi)。\n","excerpt":"项目要做一个可以为日记添加音乐的小程序，所以要用到音乐api，参考了一些文章后我们封装了一个qq音乐api库（完成了动态token获取，音乐搜索，音乐专辑图片，音乐名称，歌手名称，播放），有需要的可以到Github自提。   小程序qq音乐api库Gihub地址 https://github.com/FisherWY…"},{"slug":"posts/code/mini-program-network","title":"小程序异步网络请求问题的解决方案","content":"---\ntitle: \"小程序异步网络请求问题的解决方案\"\ndate: 2020-12-08T15:38:11+08:00\ncategories: [\"code\"]\ntags: [\"javascript\",\"小程序\"]\ndraft: false\n---\n\n### 业务逻辑\n\n最近开发一个便签小程序的时候，有这样一个需求：用户可以在写便签的时候添加一个或多个图片。\n\n对于这个需求，我们用户按下保存键时，内部具体的实现上是这样的逻辑：\n\n1. 首先检测用户是否传入了图片，如果存储本地图片地址的数组长度>=1,则将图片数组放入上传图片的函数。\n\n2. 由于小程序网络请求大小限制，我们只能采取循环上传单文件，然后收集每次请求的结果--图片在服务器的地址，最后将结果放在一个数组中供后续的操作使用。\n\n3. 当图片上传函数全部执行完毕后，将数组中的图片数组取出来，赋值到日记对象中，再将整个日记对象提交到服务器。\n\n4. 服务器返回保存成功或失败。\n\n思路其实非常清晰简单，但是在代码实现上却翻了大跟头。\n\n### 异步带来的问题\n\n小程序的网络请求是异步的：我们无法通过return来将网络请求结果返回出来使用。\n\n```js\n\n    wx.request({\n\n          //...省略其他属性\n\n          success: function (res) {\n\n          },\n\n          fail: function (res) {\n\n          }\n\n    })\n\n ```\n\n例如在微信中发送网络请求，我们只能使用微信提供的方法wx.xxx，其中请求的结果保存在res中，而res无法直接return得到。\n\n**解决：**res虽然无法直接获取，但是我们能通过将需要使用到这个请求结果的业务逻辑代码放入这个网络请求的回调函数中直接读取网络请求结果，也就是一切都需要通过回调来解决。\n\n```js\n\n    wx.request({\n\n          //...省略其他属性\n\n          success: function (res) {\n\n            console.log(res);\n\n            //接业务逻辑代码\n\n          },\n\n          fail: function (res) {\n\n            console.log(res);\n\n          }\n\n    })\n ```\n\n例如这个微信的网络请求，我们可以通过success和fail的回调函数来读取res的值从而完成依赖res结果的业务逻辑。\n\n#### 回调地狱\n\n虽然解决了结果获取的问题，但是又产生了另一个问题，当多个请求中有明确的先后顺序时，回调会嵌套的很厉害，造成回调地狱，代码可读性和可维护性都会很差。\n例如对于一个日记页面，需要先请求到页面的数据（里面包含了图片数据和其他数据的地址），再根据页面数据去请求图片数据后再请求音频数据。例如以下代码：\n\n ```js\n\n    //请求页面整体数据\n\n    wx.request({\n\n          //...省略其他属性\n\n          success: function (res) {//成功\n\n                //请求图片数据\n\n                wx.request({\n\n                  success: function (res) {//成功\n\n                      //请求音频数据\n\n                      wx.request({\n\n                          success: function (res) {//成功\n\n                          },\n\n                          fail: function (res) {//失败\n\n                              console.log(\"请求失败:\"+res);\n\n                          }\n\n                      })\n\n                  },\n\n                  fail: function (res) {//失败\n\n                      console.log(\"请求失败:\"+res);\n\n                  }\n\n                })\n\n          },\n\n          fail: function (res) {//失败\n\n              console.log(\"请求失败:\"+res);\n\n          }\n\n    })\n```\n\n**如何优化？**幸运的是，在es6里面我们可以用promise去优化我们的回调，用then代替回调，首先将网络请求封装成一个Promise：\n\n```js\n\n    // 后台post请求\n\n    function postRequest(posturl, postdata) {\n\n      return new Promise((resolve, reject) => {\n\n        wx.request({\n\n          //省略其他属性\n\n          success: function (res) {\n\n            console.log(\"at post request: 请求成功\")\n\n            resolve(res.data)//设置promise成功标志\n\n          },\n\n          fail: function (res) {\n\n            console.log(\"at post request: 请求失败\")\n\n            reject(res.data)//设置promise失败标志\n\n          }\n\n        })\n\n      });\n\n    }\n\n```\n\n这样封装以后，我们的网络请求会在success和fail后回调resolve,这样可以告诉promise，“hey，我完成我的工作了，你可以进行你的then操作了”，这样就可以用then来简化嵌套逻辑。使用promise来完成上面那个问题的请求将会是这样的：\n\n```js\n\n    postRequest(posturl,postdata)\n\n    .then(function(res){\n\n      //业务逻辑\n\n      //调用下一个请求\n\n      return postRequest(next_posturl,next_postdata);\n\n    })\n\n    .then(function(res){\n\n      //业务逻辑\n\n      //调用下一个请求\n\n      return postRequest(next_next_posturl,next_next_postdata);\n\n    })\n\n    .then(function(res){\n\n      //业务逻辑\n\n    });\n\n```\n\n是不是简洁的多~\n\n### 一个看似简单的需求\n\n我们的有一个很简单的需求是需要对一组数量不定的图片做分别上传（因为微信限制所以无法做多上传），并且在上传完成以后需要获取到所有的返回结果。\n\n那么用我们前面的回调函数+then的话，很自然的想到这样的写法\n\n```js\n\npostRequest(posturl,postdata)\n\n.then(function(res){\n\n    //获取返回res\n\n    //上传下一个图片\n\n    return postRequest(next_posturl,next_postdata);\n\n})\n\n.then(function(res){\n\n    //获取返回res\n\n    //上传下一个图片\n\n    return postRequest(next_next_posturl,next_next_postdata);\n\n})\n\n.then(function(res){\n\n    //获取返回res\n\n});\n\n```\n\n这样看起来很简单明了，但是我的图片数量是不定的，怎么动态的构建.then.then.then这样的链式调用呢？经过我的研究后发现可以通过一个辅助的promise链去完成主链的链式构建。\n\n```js\n\n//多文件上传\n\nfunction jabingp_upLoad(uploadurl, files) {\n\n  return new Promise((resolve, reject) => {\n\n    //初始化promise链\n\n    var mergedAjax = Promise.resolve();\n\n    var response = [];\n\n    // 循环上传\n\n   \n    // 这里一定要使用let来为没一次循环构建一个块级作用域\n    // 使用var则需要配合立即执行函数\n    for (let i = 0; i < files.length; i++) {\n\n      mergedAjax = mergedAjax.then(() => {\n\n        return jabingp_upLoadSingle(uploadurl, files[i]).then((res) => {\n\n          response.push(res);\n\n        });\n\n      });\n\n    }\n\n    //当前面循环中所有的then执行完毕时会执行这个then\n\n    mergedAjax.then(() => {\n\n      resolve(response);            //设置这个函数的promise对象为完成状态并放入数据\n\n    });\n\n  });\n\n}\n\n```\n\n通过这个函数，就完成了多个请求依次执行并收集结果的效果。这个函数的重点在于利用另外一个已经处于完成状态的promise，不断的迭代自身，在每次迭代的then内部通过return来完成辅助链到业务链的切换。\n\n> 2019-04-27 更新\n\n### 使用await/async更加优雅地处理异步吧\n\n在es7标准中，引入了await和async这对兄弟，它们可以让我们的异步代码看起来和同步代码一样。让我们来看看await和async都能做什么吧。\n\nawait可以等待一个promise运行到完成状态并且获取结果，或者等待一个async修饰的函数运行完成并获取结果，但是使用await的时候，必须在async函数体内部。比如我有这样一个网络请求:\n\n```js\n function postRequest(posturl, postdata) {\n\n     return new Promise((resolve, reject) => {\n\n       wx.request({\n\n         //省略其他属性\n\n         success: function (res) {\n\n           console.log(\"at post request: 请求成功\")\n\n           resolve(res.data)//设置promise成功标志\n\n         },\n\n         fail: function (res) {\n\n           console.log(\"at post request: 请求失败\")\n\n           reject(res.data)//设置promise失败标志\n\n         }\n\n       })\n\n     });\n\n   }\n```\n\n那么如果不使用await，我就需要这样取得请求结果\n\n```js\nfunction test(){\n  postRequest(xxx,xxx).then(function(res){\n      // 这里面可以读取请求结果res了\n      console.log(res);\n  });\n}\ntest();\n```\n\n可以看到，这样的代码不太符合常规逻辑，我们希望函数作用是返回数据，这样更清晰明了，有了await，我们的愿望就可以实现了。\n\n```js\nasync function test(){\n let res = await  postRequest(xxx,xxx);\n // 下面就可以正常写对res的读取了\n console.log(res);\n}\ntest();\n```\n\n注意我给函数加上了async，有了async和await，我们就可以像同步代码一样使用异步请求了~\n那么上面那个通过复杂的构建链完成的需求，通过await实现将会变得非常简单易懂。\n\n```js\nasync function jabingp_upLoad(uploadurl, files) {\n    let response = [];\n  \n    // 循环依次等待上传结果\n    for (let i = 0; i < files.length; i++) {\n        let  res = await jabingp_upLoadSingle(uploadurl, files[i]);\n        // 结果放入数组\n        response.push(res);\n    }\n    // 返回结果\n    return  response ;\n}\n\n```\n\n代码一下子变得简洁易懂了，注意调用的时候也同样需要在一个async函数内部执行await。\n\n```js\nasync function test(){\n let response = await  jabingp_upLoad(xxx,xxx);\n console.log(response );\n}\ntest();\n```\n\n是不是非常简单呢，赶紧在你的异步请求中使用async和await吧！\n","excerpt":"业务逻辑 最近开发一个便签小程序的时候，有这样一个需求：用户可以在写便签的时候添加一个或多个图片。 对于这个需求，我们用户按下保存键时，内部具体的实现上是这样的逻辑： 首先检测用户是否传入了图片，如果存储本地图片地址的数组长度>=…"},{"slug":"posts/code/my-confusion","title":"那些让我困惑的事情","content":"---\ntitle: \"那些让我困惑的事情\"\ndate: 2020-12-29T13:42:13+08:00\ncategories: [\"code\"]\ntags: [\"confusion\"]\ndraft: false\n---\n\n## 1.《Linux设计与实现》中的task_struct\n\n- [ ] 是否解决\n\n\n在阅读 *《Linux设计与实现》* 3.2.2 时，留意到这样一段话：\n\n> 内核通过一个唯一的进程标识值（process identification value）或 *PID* 来标识每个进程。 *PID* 是一个数，标识 *pid_t* *隐含类型*（ *隐含类型* 指数据类型的表示是未知的或不相关的），实际上就是一个 *int* 类型。为了与老版本的 *Unix* 和 *Linux* 兼容， *PID* 的最大值默认设置为 **32768（short int短整型的最大值）** ，尽管这个值也可以增加到高达400万（这受<linux/threads.h>中所定义PID最大值的限制）。内核把每个进程的 *PID* 存放在它们各自的 *进程描述符* 中。\n\n\n> 这个最大值很重要，因为它实际上就是系统中允许同时存在的进程的最大数目。尽管 **32768** 对于一般的桌面系统足够用了，但是大型服务器可能需要更多进程。这个值越小，转一圈就越快，本来数值大的进程比数值小的进程迟运行，但这样一来就破坏了这一原则。\n\n疑惑的点在于这句：\n\n> 这个值越小，转一圈就越快，本来数值大的进程比数值小的进程迟运行，但这样一来就破坏了这一原则。\n\n我可以理解 *“数值大的进程比数值小的进程迟运行”* ，但无法理解为什么 *pid* 设置的越小就会破坏这一原则。\n\n起初我觉得可能是中文翻译问题，于是我找到了英文原版，里面同一段话的英文原文是：\n\n> the lower\nthe value, the sooner the values will wrap around, destroying the useful notion that higher values indicate later-run processes than lower values.\n\n中文版虽然拗口了一点点，但是意思是没什么问题的，证明不是翻译导致的语义不明确。\n\n## 2. Openwrt 或者 Lede 无法在通过内网的域名访问\n\n1. 直接通过 ip 访问可以成功访问到luci\n2. 修改电脑的 hosts文件\n\n```bash\n192.168.123.73 openwrt.lan\n```\n\n3. 访问 openwrt.lan 出现\n\n```bash\n500 Internal Privoxy Error\nPrivoxy encountered an error while processing your request:\n\nCould not load template file no-server-data or one of its included components.\n\nPlease contact your proxy administrator.\n\nIf you are the proxy administrator, please put the required file(s)in the (confdir)/templates directory. The location of the (confdir) directory is specified in the main Privoxy config file. (It's typically the Privoxy install directory, or /etc/privoxy/).\n```\n\n## 提示根据法律规定，koolshare软件中心不会安装此插件\n\nsed -i 's/\\tdetect_package/\\t# detect_package/g' /koolshare/scripts/ks_tar_install.sh","excerpt":"1.《Linux设计与实现》中的task_struct 是否解决 在阅读  《Linux设计与实现》  3.2.2 时，留意到这样一段话： 内核通过一个唯一的进程标识值（process identification value）或  PID  来标识每个进程。  PID  是一个数，标识  pid_t…"},{"slug":"posts/code/netease-cloud-music-api","title":"为微信小程序开发的网易云音乐api库","content":"---\ntitle: \"为微信小程序开发的网易云音乐api库\"\ndate: 2020-12-08T20:25:36+08:00\ncategories: [\"code\"]\ntags: [\"javascript\", \"小程序\", \"音乐外链\", \"网易云音乐\"]\ndraft: false\n---\n\n> 之前我们已经开发过一款小程序适用的qq音乐api库[https://github.com/FisherWY/QQMusicPlugin](https://github.com/FisherWY/QQMusicPlugin)了，这次开发网易云音乐api库的原因是qq音乐api库在小程序中iOS环境下无法使用小程序提供的背景音频播放器播放的问题\n> 网易云的加密算法真的比其他几家api复杂太多了。。。完爆QQ和酷狗想要直接用的话可以到Github直接取我封装好的api库。Github地址[https://github.com/JabinGP/NetEaseCloudMusicApi](https://github.com/JabinGP/NetEaseCloudMusicApi)\n\n### 依赖\n\n本api库参考了Github上面开源的node库，因为我们只想要查找音乐和播放音乐这两个功能，虽然Github那个库很方便，但是我们不想为了两个接口特意去跑一个node.js服务。\n\n1. big-integer.js  \n  这里注意，不要使用最新版的，最新版的库再模拟器上运行没有问题，但是在真机调试的上传包阶段会报错说无法识别big-integer.js，最后在我的尝试下，选用了一个老版本的库解决了这个问题。\n2. crypto-js\n这个库是用来aes加密的，在node上面有一个原生的crypto，但是在小程序里我们没有，所以我照着Github上的源码一点一点用这个库翻译过来的，还有Buffer在小程序里也没有，我使用这个库的方法代替了。\n\n### 获取api的原理\n\n网上很多帖子讲的很清楚了，这里推荐几篇文章，我只做一个简单的总结，方便大家理解这个库。\n网易云的加密算法大概使用了两个：\n\n1. AES加密+BASE64编码\n2. RSA加密\n\n加密大致流程：\n\n1. api请求信息先被转成json字符串格式，然后再使用一个固定的密钥aes+base64编码加密，得到了第一个`加密结果a`。\n\n2. 客户端从`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/`随机生成一个新的16位密钥，然后用这个密钥去加密`加密结果a`，得到`加密结果b`。\n\n3. 这样我们的数据就被双重加密了，但是我们要发给服务器去查询对应的数据，服务器知道第一个固定的密钥是多少，可以解开第一个加密结果，但是服务器可不知道我们第二次加密用的是什么，所以服务器还需要得到我们的第二个生成的随机加密密钥。\n\n4. 第二个随机加密密钥要是直接发给服务器好像就不太安全了，所以客户端对第二个随机加密密钥也进行了加密，使用的就是RSA加密，加密后得到的数据我们称为`c`\n\n5. 将`b`和`c`发送给服务器，服务器就会返回给我们对应的结果了。\n\n### 加密核心代码\n\n这段代码传入对象后可以直接加密成符合网易云api加密的结果。\n\n```javascript\n// 生成随机数，size默认16\nfunction createSecretKey(size) {\n    const keys = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n    let key = \"\"\n    for (let i = 0; i < size; i++) {\n        let pos = Math.random() * keys.length\n        pos = Math.floor(pos)\n        key = key + keys.charAt(pos)\n    }\n    return key\n}\n\n\n// aes加密方法\nfunction aesEncrypt(word, secKey) {\n    let key = CryptoJS.enc.Utf8.parse(secKey);  //十六位十六进制数作为密钥\n    let iv = CryptoJS.enc.Utf8.parse(aes_mv);   //十六位十六进制数作为密钥偏移量\n    let srcs = CryptoJS.enc.Utf8.parse(word);\n    let encrypted = CryptoJS.AES.encrypt(srcs, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 });\n    let res = encrypted.toString();\n    console.log(res);\n    return res;\n}\n\n// 填充方法\nfunction zfill(str, size) {\n    while (str.length < size) str = \"0\" + str\n    return str\n}\n\n// rsa加密方法\nfunction rsaEncrypt(text, pubKey, modulus) {\n    const _text = text.split('').reverse().join('')\n    const biText = bigInt(CryptoJS.enc.Utf8.parse(_text).toString(), 16),\n        biEx = bigInt(pubKey, 16),\n        biMod = bigInt(modulus, 16),\n        biRet = biText.modPow(biEx, biMod)\n    return zfill(biRet.toString(16), 256)\n}\n\n\n// 加密总入口\nfunction Encrypt(obj) {\n    const text = JSON.stringify(obj)\n    const secKey = createSecretKey(16)\n    const encText = aesEncrypt(aesEncrypt(text, nonce), secKey)\n    const encSecKey = rsaEncrypt(secKey, pubKey, modulus)\n    return {\n        params: encText,\n        encSecKey: encSecKey\n    }\n}\n```\n\n### 封装好的Api库\n\n首先到Github下载我的Api库[https://github.com/JabinGP/NetEaseCloudMusicApi\n](https://github.com/JabinGP/NetEaseCloudMusicApi\n)下载完成后，这个库应该是可以直接导入微信小程序开发工具运行的，但是有几个注意事项:\n\n1. 这个库是用TypeScript写的，但是最后编译成了JS运行，但是编译后JS代码可读性很差，所以我保留了TypeScript源文件，就在NetEaseCloudMusicApi/ts_src里面，应用库的时候不需要使用到\n\n2. 关闭小程序开发工具的详情页的`ES6转ES5`，可以使用await处理异步请求（因为库是用`Promise`写的，起码要能用`Promise`，实例代码使用的是`await`/`async`）\n\n3. await关键字只能在async修饰过的函数体内部使用，不懂的可以查一下await和async的用法。\n\n4. `NetEaseCloudMusicApi/Libary`文件夹里面包含了项目依赖的js文件，应用的时候最好整个`NetEaseCloudMusicApi`文件夹复制到项目里面使用。\n\n5. 测试的时候可以勾选不校验合法域名。\n\n![1](https://upload-images.jianshu.io/upload_images/14225973-b53fa739408a3105.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 开始使用之前的准备\n\n1. 找到NetEaseCloudMusicApi这个文件夹，里面应该包括Libary、src、ts_src三个文件夹，Libary是我引用的开源库，ts_src中是TypeScript源文件，src是ts_src编译后产生的JavaScript文件夹，也就是说不考虑读ts源文件的话，可以把ts_src删了，但是17.4 KB 的大小对应用包体积应该没有什么影响吧，留着也行。\n\n2. 在要使用到的库中如下引用\n\n```js\nconst {MusicManager} = require(\"../../NetEaseCloudMusicApi/src/MusicManager\");\n```\n\n注意要用花括号吧`MusicManager`括起来，这一句可以需要变化的地方只有\n`../../NetEaseCloudMusicApi/src/MusicManager`中的`../../`，后面的路径都代表了`NetEaseCloudMusicApi`文件夹和`NetEaseCloudMusicApi`里面文件的路径，因为我的库就是这样的结构，所以不需要改变，`../../`就要根据你项目中实际结构来改变了。\n\n### MusicManager\n\n该类有以下方法：该类提供了所有获取其他对象的方法，可以通过该类获取其他需要的对象而不是new\n\n- `getMusicSearchHelper()`\n需要参数：`{keyword:\"搜索歌曲关键词\",limit:数字}`\n返回：`MusicSearchHelper`搜索器\n- `getMusicUrlHelper()`\n 需要参数：`musicId`（数字类型的歌曲id）\n返回：`MusicUrlHelper`Url获取器\n- `getUserSearchHelper()`\n需要参数：`{userName:\"搜索用户的用户名关键词\",limit:数字}`\n返回：`UserSearchHelper`用户查询器\n- `getUserListHelper()`\n需要参数：`userId`（数字类型的用户id值）\n返回：`UserListHelper`用户列表查询器\n- `getUserListDetailHelper()`\n需要参数：`listId`（数字类型的列表id）\n返回：`UserListDetailHelper`用户列表详情信息获取器\n\n### MusicSearchHelper\n\n用于搜索音乐\n可用方法：\n\n- `getSearchResult()`---获取数据（默认第一页）\n- `nextPage()`--- 下一页\n- `previousPage()`---上一页\n- `getCurrentPage()`---查看当前页数的\n\n执行完切换页数后需要再次调用`getSearchResult`方法查看新的查询结果。\n\n### MusicUrlHelper\n\n用于将搜索音乐结果中的id转换为url播放链接\n可用方法：\n\n- `getUrlResult()` ---获取url播放链接\n\n### UserSearchHelper\n\n用于根据用户名关键字搜索用户\n可用方法：\n\n- `getSearchResult()`---获取搜索结果\n\n### UserListHelper\n\n用于获取用户id后根据id获取用户歌单信息\n可用方法：\n\n- `getAllLists()`---获取用户所有歌单\n- `getILikeList()`---获取用户的我喜欢歌单\n\n### UserListDetailHelper\n\n用于获取歌单id后获取歌单内歌曲列表\n可用方法：\n\n- `getDeatil()`---获取歌单内列表\n\n### 搜索歌曲\n\n1. 通过`MusicManager`获取一个`MusicSearchHelper`搜索器\n\n2. `MusicSearchHelper`的方法：\n    - `getSearchResult()`---获取数据（默认第一页）\n    - `nextPage()`--- 下一页\n    - `previousPage()`---上一页\n    - `getCurrentPage()`---查看当前页数的\n\n3. 执行完切换页数后需要再次调用`getSearchResult`方法查看新的查询结果。\n\n代码实例\n\n```javascript\nconst {MusicManager} = require(\"../../NetEaseCloudMusicApi/src/MusicManager\");\nasync function test(){\n     // 搜索歌曲\n    let musicSearchHelper = MusicManager.getMusicSearchHelper({ keyword: \"one more time one more chance\", limit: 10 });\n    console.log(`现在是第${musicSearchHelper.getCurrentPage()}页`);\n    console.log(await musicSearchHelper.getSearchResult());\n    musicSearchHelper.nextPage();\n    console.log(`现在是第${musicSearchHelper.getCurrentPage()}页`);\n    console.log(await musicSearchHelper.getSearchResult());\n    musicSearchHelper.previousPage();\n    console.log(`现在是第${musicSearchHelper.getCurrentPage()}页`);\n    console.log(await musicSearchHelper.getSearchResult());\n    console.log(musicSearchHelper);\n} \ntest();\n```\n\n![2](https://upload-images.jianshu.io/upload_images/14225973-0977450d4401c36b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 通过搜索歌曲的结果获取音乐Url\n\n有了搜索结果，我们还需要url才能播放资源\n\n1. 通过`MusicManager`获取一个`MusicUrlHelper`Url获取器\n2. 通过`MusicUrlHelper`的`getUrlResult`方法获取url\n3. ~~需要注意的是，由于网易云接口时常返回空回复，所以这里我通过20以内的重复次请求直到有结果就停止，如果20次以后还是没有结果（据我测试20次以内都请求到结果了），也就是返回一个空的字符串\"\"，需要使用者自己重新调用一次`urlHelper`的`getUrlResult`方法~~(2019.04.27）现在不会返回空值了，返回空值发现问题出在使用微信请求时自作聪明将json转成了a=xxxx&b=xxx的格式，导致微信不能正常转换请求数据，现在每次请求都能获取结果。\n代码实例\n\n```javascript\nconst {MusicManager} = require(\"../../NetEaseCloudMusicApi/src/MusicManager\");\n\nasync function test(){\n    // 搜索歌曲\n    let musicSearchHelper = MusicManager.getMusicSearchHelper({ keyword: \"one more time one more chance\", limit: 10 });\n    console.log(`现在是第${musicSearchHelper.getCurrentPage()}页`);\n    console.log(await musicSearchHelper.getSearchResult());\n    musicSearchHelper.nextPage();\n    console.log(`现在是第${musicSearchHelper.getCurrentPage()}页`);\n    console.log(await musicSearchHelper.getSearchResult());\n    musicSearchHelper.previousPage();\n    console.log(`现在是第${musicSearchHelper.getCurrentPage()}页`);\n    console.log(await musicSearchHelper.getSearchResult());\n    console.log(musicSearchHelper);\n\n    // 获取歌曲url\n    let songs = await musicSearchHelper.getSearchResult();\n    let musicId  = songs[0].id;\n    let musicUrlHelper = MusicManager.getMusicUrlHelper(musicId);\n    console.log(`歌曲的ID是：${musicId}`);\n    let url = await musicUrlHelper.getUrlResult();\n    console.log(`歌曲的url链接是：${url}`);\n} \ntest();\n```\n\n![3](https://upload-images.jianshu.io/upload_images/14225973-ded0cd2b34269afe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 4.26更新\n\n新增搜索用户以及用户歌单获取接口\n\n#### 搜索用户\n\n1. 通过`MusicManager`获取一个`UserSearchHelper`用户查询器\n2. 通过`UserSearchHelper`的`getSearchResult()`方法获取搜索结果\n\n```javascript\nasync function test(){\n  // 搜索用户\n  let userSearchHelper = MusicManager.getUserSearchHelper({ userName: \"JabinGP\", limit: 20 });\n  let users = await userSearchHelper.getSearchResult();\n  console.log(users);\n}\n```\n\n#### 获取用户歌单\n\n1. 通过`MusicManager`获取一个`UserListHelper`用户查询器\n2. 通过`UserListHelper`的\n    - `getILikeList()` ---获取我喜欢歌单，返回一个列表对象\n    - `getAllLists()`---获取所有歌单，返回一个列表对象的数组\n\n```javascript\nasync function test(){\n  // 搜索用户\n  let userSearchHelper = MusicManager.getUserSearchHelper({ userName: \"JabinGP\", limit: 20 });\n  let users = await userSearchHelper.getSearchResult();\n  console.log(users);\n  \n  // 获取我喜欢歌单\n  let userListHelper = MusicManager.getUserListHelper(users[0].userId);\n  let iLikeList = await userListHelper.getILikeList()\n  console.log(iLikeList);\n }\n```\n\n#### 通过歌单里的Id获取歌曲url\n\n与前面一致，不再赘述\n\n#### 完整实例\n\n完整实例代码在项目page下的index.js中，运行项目就会自动执行输出结果。\n\n```javascript\nasync function test(){\n    // 搜索歌曲\n    let musicSearchHelper = MusicManager.getMusicSearchHelper({ keyword: \"one more time one more chance\", limit: 10 });\n    console.log(`现在是第${musicSearchHelper.getCurrentPage()}页`);\n    console.log(await musicSearchHelper.getSearchResult());\n    musicSearchHelper.nextPage();\n    console.log(`现在是第${musicSearchHelper.getCurrentPage()}页`);\n    console.log(await musicSearchHelper.getSearchResult());\n    musicSearchHelper.previousPage();\n    console.log(`现在是第${musicSearchHelper.getCurrentPage()}页`);\n    console.log(await musicSearchHelper.getSearchResult());\n    console.log(musicSearchHelper);\n\n    // 获取歌曲url\n    let songs = await musicSearchHelper.getSearchResult();\n    let musicId  = songs[0].id;\n    let musicUrlHelper = MusicManager.getMusicUrlHelper(musicId);\n    console.log(`歌曲的ID是：${musicId}`);\n    let url = await musicUrlHelper.getUrlResult();\n    console.log(`歌曲的url链接是：${url}`);\n\n    // 搜索用户\n    let userSearchHelper = MusicManager.getUserSearchHelper({ userName: \"JabinGP\", limit: 20 });\n    let users = await userSearchHelper.getSearchResult();\n    console.log(users);\n\n    // 获取用户歌单\n    let userListHelper = MusicManager.getUserListHelper(users[0].userId);\n    let iLikeList = await userListHelper.getILikeList()\n    console.log(iLikeList);\n    \n    // 获取我喜欢歌单\n    let userListDeatilHelper = MusicManager.getUserListDetailHelper(iLikeList.id);\n    let listDetail = await userListDeatilHelper.getDeatil();\n    console.log(listDetail);\n    let timer=0;\n    for(let song of listDetail.tracks){\n      musicUrlHelper.musicId=song.id;\n      console.log(`歌曲的ID是：${musicUrlHelper.musicId}`);\n      let url2 = await musicUrlHelper.getUrlResult();\n      console.log(`歌曲的url链接是：${url2}`);\n      if(timer++>20)break;\n    }\n  }   \ntest();\n```\n\n### 结尾\n\n> 2019 4.25目前就只有这两个接口，因为我们项目就只需要这两个接口，如果有需要更多接口的，可以在下方评论，以上示例代码都在Github项目上的index.js中，也就是你把文件导入微信开发者工具后，取消勾选一下详情的ES6转ES5以及取消勾选合法域名检验，就可以在控制台看到以上示例代码的输出了\n> 2019 4.26更新搜索用户和获取用户歌单以及获取歌单详细三个接口。\n\n如果对你有帮助，点个Star吧~\n","excerpt":"之前我们已经开发过一款小程序适用的qq音乐api库 https://github.com/FisherWY/QQMusicPlugin 了，这次开发网易云音乐api库的原因是qq音乐api库在小程序中iOS环境下无法使用小程序提供的背景音频播放器播放的问题\n网易云的加密算法真的比其他几家api复杂太多了。。。完爆QQ…"},{"slug":"posts/code/node-koa2-session-login","title":"Node.js的Koa2中如何使用Session完成登录功能？","content":"---\ntitle: \"Node.js的Koa2中如何使用Session完成登录功能？\"\ndate: 2020-12-08T21:08:05+08:00\ncategories: [\"code\"]\ntags: [\"login\",\"session\",\"koa\",\"koa2\",\"JavaScript\",\"cookie\"]\ndraft: false\n---\n\n> 项目要用到登录注册，就需要使用到Cookie和Session来保持登录状态，于是就简单研究了一下\n\n### Cookie和Session的工作原理\n\n前面已经专门发过一篇帖子记录Cookie和Session的工作原理了，不明白的小伙伴可以看看[Cookie、Session是如何保持登录状态的？](https://segmentfault.com/a/1190000019065025)。\n\n### 使用Koa的Session中间件\n\nKoa是一个简洁的框架，把许多小功能都拆分成了中间件，用一个洋葱模型保证了中间件丰富的可拓展性，我们要使用Session来保持登录状态，就需要引用Session中间件。\n\n### 安装Koa-Session中间件\n\n```cmd\nnpm install koa-session --save\n```\n\n如果需要使用TypeScript进行开发，则需要引入对应的TS类型声明\n\n```cmd\nnpm install @types/koa-session --save\n```\n\n### 配置Session\n\nKoa-Session需要做一些配置：\n\n```JavaScript\nconst session_signed_key = [\"some secret hurr\"];  // 这个是配合signed属性的签名key\nconst session_config = {\n    key: 'koa:sess', /**  cookie的key。 (默认是 koa:sess) */\n    maxAge: 4000,   /**  session 过期时间，以毫秒ms为单位计算 。*/\n    autoCommit: true, /** 自动提交到响应头。(默认是 true) */\n    overwrite: true, /** 是否允许重写 。(默认是 true) */\n    httpOnly: true, /** 是否设置HttpOnly，如果在Cookie中设置了\"HttpOnly\"属性，那么通过程序(JS脚本、Applet等)将无法读取到Cookie信息，这样能有效的防止XSS攻击。  (默认 true) */\n    signed: true, /** 是否签名。(默认是 true) */\n    rolling: true, /** 是否每次响应时刷新Session的有效期。(默认是 false) */\n    renew: false, /** 是否在Session快过期时刷新Session的有效期。(默认是 false) */\n};\n```\n\n我们需要关注这几个配置：\n\n- renew rolling\n这两个都可以在用户访问的过程中刷新有效期，不至于让用户访问过程中Session过期成为未登录状态\n- signed\n这个是对客户端Cookie的签名，也就是用一个特点的字符加密，保证客户端Cookie不会被伪造出来\n- httpOnly\n打开这个使得通过程序(JS脚本、Applet等)无法读取Cookie，大大提高了安全性\n- maxAge\n以ms为单位的过期时间\n\n### 简单的使用\n\n首先理一下思路\n\n1. 判断访问者的Session有没有过登录记录属性\n2. 如果有且值为true，则为已登录，否则为未登录\n3. 如果为已登录，则不执行判断，直接返回已登录，如果为未登录，则执行下一步登录验证\n4. 如果验证成功，则返回的登录成功，并且在它的session中记下登录属性为true，如果验证失败，则返回登录失败。\n\n> 为了测试方便，以下用Get请求和一个固定的账号密码代替数据库查询，实际开发应该使用POST和数据库比对。同时为了测试方便，将过期时间设置为4000ms，便于快速看到Cookies过期，实际开发应该设置长一些，比如几小时甚至几天，取决于业务需求。\n\n```JavaScript\nconst Koa = require('koa');                               // 导入Koa\nconst Koa_Session = require('koa-session');   // 导入koa-session     \n// 配置\nconst session_signed_key = [\"some secret hurr\"];  // 这个是配合signed属性的签名key\nconst session_config = {\n    key: 'koa:sess', /**  cookie的key。 (默认是 koa:sess) */\n    maxAge: 4000,   /**  session 过期时间，以毫秒ms为单位计算 。*/\n    autoCommit: true, /** 自动提交到响应头。(默认是 true) */\n    overwrite: true, /** 是否允许重写 。(默认是 true) */\n    httpOnly: true, /** 是否设置HttpOnly，如果在Cookie中设置了\"HttpOnly\"属性，那么通过程序(JS脚本、Applet等)将无法读取到Cookie信息，这样能有效的防止XSS攻击。  (默认 true) */\n    signed: true, /** 是否签名。(默认是 true) */\n    rolling: true, /** 是否每次响应时刷新Session的有效期。(默认是 false) */\n    renew: false, /** 是否在Session快过期时刷新Session的有效期。(默认是 false) */\n};\n\n// 实例化\nconst app = new Koa();\nconst session = Koa_Session(session_config, app)\napp.keys = session_signed_key;\n\n// 使用中间件，注意有先后顺序\napp.use(session);\n\napp.use(ctx => {\n    const databaseUserName = \"testSession\";\n    const databaseUserPasswd = \"noDatabaseTest\";\n    // 对/favicon.ico网站图标请求忽略\n    if (ctx.path === '/favicon.ico') return;\n\n    if (!ctx.session.logged) {  // 如果登录属性为undefined或者false，对应未登录和登录失败\n        // 设置登录属性为false\n        ctx.session.logged = false;\n\n        // 取请求url解析后的参数对象，方便比对\n        // 如?nickname=post修改&passwd=123解析为{nickname:\"post修改\",passwd:\"123\"}\n        let query = ctx.request.query;\n\n        // 判断用户名密码是否为空\n        if (query.nickname && query.passwd) {\n\n            // 比对并分情况返回结果  \n            if (databaseUserName == query.nickname) {  // 如果存在该用户名\n\n                // 进行密码比对并返回结果 \n                ctx.body = (databaseUserPasswd == query.passwd) ? \"登录成功\" : \"用户名或密码错误\";\n                ctx.session.logged = true;\n            } else {                    // 如果不存在该用户名                                           //  如果用户名不存在\n                ctx.body = \"用户名不存在\";\n            }\n        } else {\n            ctx.body = \"用户名密码不能为空\";\n        }\n    } else {\n        ctx.body = \"已登录\";\n    }\n\n}\n);\n\napp.listen(3000);\nconsole.log(\"Koa运行在：http://127.0.0.1:3000\");   \n```\n\n运行一下，控制台输出：\n\n```cmd\nKoa运行在：http://127.0.0.1:3000\n```\n\n访问[http://127.0.0.1:3000](http://127.0.0.1:3000)，可以看到我们没有填写登录参数，然后返回了用户名密码不能空，并且按下F12，点击Cookies再点击[http://127.0.0.1:3000](http://127.0.0.1:3000)，看到了我们的SessionId被记录到了Cookies中，说明Session生效了。\n![1](https://upload-images.jianshu.io/upload_images/14225973-8ae8fb28dcfe78a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们静置一会但不刷新页面，再点击Cookies后重新点击，[http://127.0.0.1:3000](http://127.0.0.1:3000)（刷新Cookies显示），发现我们的SessionId不见了，说明我们的过期时间也生效了\n![2](https://upload-images.jianshu.io/upload_images/14225973-ecbf3753b37436c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我将Cookies的数据截详细一点就是这样的，可以看到有个过期时间：\n![3](https://upload-images.jianshu.io/upload_images/14225973-422c47b819d5c7cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们再访问[http://127.0.0.1:3000/?nickname=123](http://127.0.0.1:3000/?nickname=123)和[http://127.0.0.1:3000/?passwd=123](http://127.0.0.1:3000/?passwd=123)，都输出了\n![4](https://upload-images.jianshu.io/upload_images/14225973-618d9f63eaf7d2cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n访问[http://127.0.0.1:3000/?nickname=123&&passwd=123](http://127.0.0.1:3000/?nickname=123&&passwd=123)，输出\n![5](https://upload-images.jianshu.io/upload_images/14225973-04fc4fc688e30868.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n访问[http://127.0.0.1:3000/?nickname=testSession&&passwd=123](http://127.0.0.1:3000/?nickname=testSession&&passwd=123)，输出\n![6](https://upload-images.jianshu.io/upload_images/14225973-236ee36413c040fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n最后尝试正确的用户名密码[http://127.0.0.1:3000/?nickname=testSession&&passwd=noDatabaseTest](http://127.0.0.1:3000/?nickname=testSession&&passwd=noDatabaseTest)\n，输出![登录成功](https://upload-images.jianshu.io/upload_images/14225973-a67d3a9bdbc9b3ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n尝试再次访问[http://127.0.0.1:3000/?nickname=testSession&&passwd=noDatabaseTest](http://127.0.0.1:3000/?nickname=testSession&&passwd=noDatabaseTest)\n，输出\n\n![重复登录](https://upload-images.jianshu.io/upload_images/14225973-3fbd253861481a36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在有效期限内访问别的页面[http://127.0.0.1:3000/](http://127.0.0.1:3000/)，输出\n![有效期内](https://upload-images.jianshu.io/upload_images/14225973-8783aac616ff79aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n有效期内不断刷新就能保持登录状态\n![不断刷新](https://upload-images.jianshu.io/upload_images/14225973-5152a1573021dfe8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n有效期内没有重新操作页面刷新状态就会自然过期\n![过期](https://upload-images.jianshu.io/upload_images/14225973-9853d8e5e14bf4df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","excerpt":"项目要用到登录注册，就需要使用到Cookie和Session来保持登录状态，于是就简单研究了一下 Cookie和Session的工作原理 前面已经专门发过一篇帖子记录Cookie和Session的工作原理了，不明白的小伙伴可以看看 Cookie、Session是如何保持登录状态的？ 。 使用Koa的Session…"},{"slug":"posts/code/os-fd","title":"操作系统系列之——文件描述符","content":"---\ntitle: \"操作系统系列之——文件描述符\"\ndate: 2021-01-14T21:33:56+08:00\ndraft: false\n---\n\n注：以下的 Unix 泛指 Unix 、 Linux 、 macOS 等系统。\n\n## 一切皆文件\n\n在 Unix 中有一种简单而实用的哲学叫做 *一切皆文件* ：文件是文件、设备是文件......\n\n## 打开是第一步\n\n一个实实在在的普通文件在使用之前必须要经过一个叫做 **打开** 的过程，通常在程序中表现为 `open()` 函数调用的形式，文件必须先被打开的原因是系统需要把文件属性和磁盘地址表装入内存以便于后续的快速访问。\n\n## 返回凭证\n\n文件在成功打开后，系统会返回一个 **非负整数** 作为文件的描述符，文件描述符将作为引用该文件的一个凭证，例如后续对该文件的读或写操作则需要将文件描述符传递给 `read()` 或 `write()` 函数。\n\n## 文件描述符的一些属性\n\n按照惯例，UNIX 系统 shell 使用文件描述 0 关联进程的标准输入、 1 关联标准输出、 2 关联标准错误输出。这是各种 shell 以及很多应用程序使用的管理，并非 UNIX 内核强制要求，但如果不遵照这个惯例，很多 UNIX 系统引用程序就并无法正常工作。\n\n// TODO: POSIX 标准\n\n在遵从 POSIX 标准的应用程序中，与标准输入、标准输出、标准错误输出想关的 0 、 1 、 2 、应该使用被定义在头文件 `<unistd.h>` 的符号常量 `STDIN_FILENO` 、 `STDOUT_FILENO` 、 `STDERR_FILENO` 来替换。\n\n## 文件描述符的服务对象\n\n文件描述符的产生归根结底是因为 **进程需要使用** 某个文件，因此文件描述符的诞生就是为了进程而服务的。\n\n因为文件描述符的针对的对象是进程，因此每个进程的文件描述符都是独立的，相同的数字在不同的进程之间的所代表的文件可以是不同的，例如同一个文件描述符 4 在 `进程1` 中代表 `文件a`，而在 `进程2` 中代表 `文件b` 。\n\n## 文件描述符的取值范围\n\n如上所述，文件描述符本质上就是一个用来标识文件的 **非负整数** ，而文件描述符范围是 [ 0, `OPEN_MAX` ] 。\n\n早期的 UNIX 系统实现采用的上限是 19 （即 [0, 19] 共 20 个取值），这意味着一个进程至多只能同时使用 20 个文件秒描述符，当需要操作的文件过多时，这可能会产生一些麻烦，但现在的操作系统已经增加至上万了，基本不存在文件描述符用完的困扰。\n\n有关 `OPEN_MAX` 的详细，可以参考 [获取进程能打开的最大文件数量【OPEN_MAX】](https://blog.csdn.net/CMbug/article/details/48313107)。\n\n## 参考\n\n- *《现代操作系统（第四版）》*\n- *《Unix环境高级编程（第四版）》*\n","excerpt":"注：以下的 Unix 泛指 Unix 、 Linux 、 macOS 等系统。 一切皆文件 在 Unix 中有一种简单而实用的哲学叫做  一切皆文件  ：文件是文件、设备是文件...... 打开是第一步 一个实实在在的普通文件在使用之前必须要经过一个叫做  打开  的过程，通常在程序中表现为  open…"},{"slug":"posts/code/os-process","title":"操作系统系列之——进程","content":"---\ntitle: \"操作系统系列之——进程\"\ndate: 2020-12-22T21:24:06+08:00\ntags: [\"os\", \"process\", \"c\"]\ncategories: [\"code\"]\ndraft: false\n---\n\n## 说明\n\n注意，在阅读这篇文章之前，请确保你已经具备以下文章中的知识：\n\n- [操作系统系列之——程序](/posts/code/os-program/)\n\n本篇文章试图让你感受到进程与程序的区别，较为深入的细节将留在后续的文章中。\n\n<!-- - [操作系统系列之——深入进程](https://blog.jabingp.cn//posts/code/linux-program/) -->\n\n## 什么是进程\n\n> 进程本质上是正在执行的一个程序，是对正在运行程序的一个抽象。——《现代操作系统》\n\n在[操作系统系列之——程序](https://blog.jabingp.cn//posts/code/linux-program/)中，我们通过 C 语言和 gcc 编译器得到了一个被存放在硬盘中的程序 `a.out` ，当它被计算机执行时就会产生一个进程。\n\n## 执行一个程序就会产生进程\n\n直接在`a.out`所在目录通过相对路径执行这个程序，可以看到程序运行并将字符输出到了控制台中：\n\n> 其中`➜  c`是命令提示符，请忽略该部分，关注提示符后面的内容。\n\n```bash\n➜  c ./a.out\nHelloWorld!                                                                                                 \n```\n\n可以看到程序中的 `printf` 被输出到当前的控制台中，说明程序确实被执行了，但这样似乎还无法证明在这个过程中有 **进程** 产生。为了证明进程的存在，我们需要做个小实验。\n\n## 进程的小实验\n\n> 再次强调，以下代码适用于类Unix系统，不同操作系统之间需要使用的库和编译工具会有所不同。\n\n首先改造一下我们的经典 HelloWorld ，引入了`unistd`来实现睡眠一段时间，我们编写程序让屏幕每隔`4s`输出一条 **带有编号的HelloWorld** ，且限制一共输出三条。\n\n```c\n#include <stdio.h>\n#include <unistd.h>\n#define SLEEP_SECONDS 4\nint main(){\n    for(int i=0; i < 3; i++){\n        sleep(SLEEP_SECONDS);\n        printf(\"No.%d: HelloWorld!\\n\",i);\n    }\n    return 0;\n}\n```\n\n编译并运行，结果是符合预期的，同时注意结果中的命令提示符 `➜  c` ，它在程序执行完毕后才出现：\n\n```bash\n➜  c ./a.out\nNo.0: HelloWorld!\nNo.1: HelloWorld!\nNo.2: HelloWorld!\n➜  c\n```\n\n为了达到实验的效果，我们需要用到 `&` 这个符号，在命令的结尾加上 `&` 则可以实现在后台运行该命令，这样我们就无需等待程序运行完毕，命令提示符会马上出现。\n\n尝试一下加上`&`会有什么变化：\n\n```bash\n➜  c ./a.out &\n[1] 63965\n➜  c No.0: HelloWorld!\nNo.1: HelloWorld!\nNo.2: HelloWorld!\n\n[1]  + 63965 done       ./a.out\n➜  c\n```\n\n可以看到加上 & 后没有等待 a.out 的执行结束而直接输出了 `[1] 63965`（其实这就是进程的 pid ），并且 **命令提示符** 马上出现，这意味着我们可以直接进行下一步的操作而不用等待 a.out 运行完毕， a.out 的运行结果也会照旧输出到当前的控制台上。\n\n现在我们可以知道`&`的作用：\n\n- 让程序在后台运行\n- 程序的输出依然不受影响\n\n现在我们可以做实验的最后一步了，首先执行一次的`./a.out &`，回车后马上通过键盘的方向上键`↑`呼出`./a.out &`再次执行一遍（一共执行两遍）。\n\n```bash\n➜  c ./a.out &\n[1] 63691\n➜  c ./a.out &\n[2] 63694\n➜  c No.0: HelloWorld!\nNo.0: HelloWorld!\nNo.1: HelloWorld!\nNo.1: HelloWorld!\nNo.2: HelloWorld!\n\n[1]  - 63691 done       ./a.out\n➜  c No.2: HelloWorld!\n\n[2]  + 63694 done       ./a.out\n➜  c\n```\n\n我们执行了两遍同一个程序，输出的结果并不是依次顺序的`0-1-2-0-1-2`，而是有些乱序的`0-0-1-1-2-2`。\n\n乱序的结果会给人一种有两个同样的程序在 **同时执行** 的感觉，但显然我们有且仅有一个存放在硬盘上的程序。这说明两次执行的的确确产生了两个 **不同的** 进程，尽管他们源于同一个程序，有着一样的运行逻辑。\n\n## 程序和进程的关系、区别\n\n`a.out`是我们的程序，但程序只是一段指令，仅仅存放在硬盘上的话它就是死的（**静态的**），只要你的硬盘不坏，这个程序放一万年都是原来的那个程序。但程序执行产生的进程是活的（**动态的**），会随着时间的推移发生状态的改变，例如当所有指令运行完毕进程就会因为无事可做而终止了。\n\n进程是由程序的执行产生的，而程序又可以被多次执行，自然地一个程序可以产生**多个**进程，但一个进程只能源于某一个程序。\n\n> 进程和程序间的区别是很微妙的，但非常重要。用一个比喻可以更容易理解这一点。想象一位有一手好厨艺的计算机科学家正在为她的女儿烘制生日蛋糕。他有做生日蛋糕的食谱，厨房里有所需的原料：面粉、鸡蛋、糖、香草汁等。在这个比喻中。做蛋糕的食谱就是程序，计算机科学家就是处理器（CPU）。而做蛋糕的各种原料就是输入数据。进程就是厨师阅读食谱、取来各种原料以及烘制蛋糕等一系列动作的总和。——《现代操作系统》\n\n## 为什么需要引入进程的概念\n\n通过`2`和`3`的例子，现在你应该知道对程序和进程有比较明确的认知了。在深入一些，这个看起来和程序没有太大区别的进程到底是出于什么原因被引入的？\n\n在今天的操作系统中，并发已经是一件非常司空见惯的事情了，一边听歌一边看博客，一边看电影一边聊天，这些在电脑上运行着的程序都是在 **操作系统** 的管理下达到同时运行互不影响的效果的。\n\n我们的电脑中能够执行指令的 **CPU** 只有一个（暂时忽略多核CPU），多个进程之间之所以能够呈现出同时运行的效果，是因为每个程序都只能被CPU执行很小一段时间，在时间结束后操作系统就换上别的程序让CPU执行（想象在 *100ms* 的时间内，每个程序只运行 *5ms*）。CPU实际上是在 **很快地切换执行** 不同的程序，而不是真正在 **同时执行** 那么多程序。\n\n而不断切换不同程序运行会导致有些程序还没运行完就失去CPU了，这要求操作系统能够知道每个程序当前的执行状态，以便于重新得到CPU时 **还原现场**，执行信息则是在每次程序失去CPU时被记录在特定的结构中（**保存现场**）。\n\n归根结底，进程是操作系统出于对运行着的程序的管理需求（**保存现场** 是其中之一）而创造出来的，被操作系统附加了信息后的结构就是 **PCB（进程控制块）**，这是真实存在于我们的电脑中的 **数据结构** ，而进程只是这个结构的 **抽象概念** 。\n","excerpt":"说明 注意，在阅读这篇文章之前，请确保你已经具备以下文章中的知识： 操作系统系列之——程序 本篇文章试图让你感受到进程与程序的区别，较为深入的细节将留在后续的文章中。 什么是进程 进程本质上是正在执行的一个程序，是对正在运行程序的一个抽象。——《现代操作系统》 在 操作系统系列之——程序 中，我们通过 C…"},{"slug":"posts/code/os-program","title":"操作系统系列之——程序","content":"---\ntitle: \"操作系统系列之——程序\"\ndate: 2020-12-21T21:24:06+08:00\ntags: [\"os\", \"program\", \"c\"]\ncategories: [\"code\"]\ndraft: false\n---\n\n> 这是这个系列的第一篇文章，如果对后续感兴趣，可以不时检查[os](https://blog.jabingp.cn/tags/os/)是否更新。\n\n## 1. 什么是程序\n\n> 计算机程序是**一组**指示电子计算机或其他具有消息处理能力设备每一步动作的**指令**。————《[维基百科：计算机程序](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F)》\n\n## 2. 程序有啥用\n\n定义中也提到了**程序**是*指示每一步动作*的**指令**，简单的说，程序就是实现某个目标所需要经历的步骤。\n\n举一个现实中的例子，当我的目标是**得到一杯手冲咖啡**时，那我实现这个目标的**程序**就是：\n\n1. 取出一包咖啡豆、V60滤杯、V60滤纸、自己喜欢的咖啡杯、够用的电子秤、尽量贵的咖啡磨豆机、一个能倒出水的手冲壶。\n2. 用电子秤秤出15g咖啡豆。\n3. 用咖啡磨豆机研磨咖啡豆，得到咖啡粉。\n4. 将手冲壶装满水。\n5. 将手冲壶里的水加热到90°\n6. 将V60滤纸放入V60滤杯中，用热水湿润后，倒干多余的水。\n7. 将咖啡粉倒入V60滤杯，滤杯架放在咖啡杯上。\n8. 将热水倒入滤杯，用电子秤观察自己的倒入的水量到达225g时停止。\n9. 等待所有热水通过滤杯滴入咖啡杯，移开滤杯。\n\n>如果你发现你看不懂这个程序，没有关系这是正常的，你只需要知道这个复杂的一系列流程其实就相当于计算机中的一个**程序**，它给出了实现**得到一杯手冲咖啡**这个目标所需要的步骤。但如果你发现这个**程序**简直跟自己每天在做的一样，请留下评论让我们交个朋友！\n\n## 3. 源代码\n\n前面举了一个比较抽象的例子，也许有的人已经get到了，有的人还是一脸雾水，接下来会继续用更具体的例子，不过这要求你对**C语言**和**命令行**有简单的了解。\n\n你现在有一个很简单的目标：**向屏幕输出三次\"HelloWorld!\"**，你很轻易地想到了你可以利用你曾学的**C语言**去实现：\n\n```c\n#include <stdio.h>\nint main(){\n    for(int i=0; i<3; i++){\n        printf(\"No.%d: HelloWorld!\\n\",i);\n    }\n    return 0;\n}\n```\n\n回顾一下这个段非常简单的源代码，除了必要的`include`、`main`、`return`等结构，核心的代码只有三行，用`for`循环`3`次，在循环内`printf`：\n\n```c\nfor(int i=0; i < 3; i++){\n    printf(\"No.%d: HelloWorld!\\n\",i);\n}\n```\n\n除了必要的结构外，实际上我们就是用这三行代码去**描述了**如何实现我们需要的目标。这是**C语言**（或者**Python**、**Java**、**JS**、**Golang**）提供给我们的一种**描述的能力**。但是到目前为止，我们所编写的这几行代码还停留在**文本**这个阶段，这是一段你能**读懂**、**修改**的**文本**，但它们并不是计算机能够**识别并执行**的**指令**。\n\n## 4. 编译源代码\n\n让**源代码**成为**程序**也很简单，对于C语言而言，只需要用C语言的**编译器**去**编译**源代码即可。\n\n## 4.1. 编译器做了什么\n\n简单地说，编译器将我们写的**源代码**翻译成了机器能执行的**二进制**。\n\n因为计算机是二进制的，在计算机的底层世界里都是`0`和`1`，但是我们直接用`0`和`1`去给计算机写程序、下指令太过**反人类**，为了便于**我们与计算机的对话**，**编程语言**应运而生。\n\n**编程语言**是更接近人能读懂的语言（尽管它依旧有不小的上手难度，但已经比更底层的指令已经好太多了），虽然人能更方便地使用编程语言编写程序了，但计算机很蠢只懂**二进制**，为了让**计算机也能理解**我们所编写的内容，就需要**编译器**来充当这中间的**翻译官**。\n\n## 4.2. 简单的编译尝试\n\n> 以下操作在类Unix系统中进行，不同操作系统的编译工具可能会不同。\n\n将`3`中的源代码保存为`main.c`，**打开命令行进入当前目录**，利用`gcc`编译工具去编译源代码，指令如下：\n\n```bash\ncd $源代码所在文件夹\ngcc main.c\n```\n\n现在main.c所在文件夹包含内容如下：\n\n- main.c\n- a.out\n\n通过gcc编译后得到了一个二进制可执行文件`a.out`。此时它被保存在硬盘的中，并且计算机也能够执行它，这时候我们才终于通过源代码获得了一个**程序**。\n","excerpt":"这是这个系列的第一篇文章，如果对后续感兴趣，可以不时检查 os 是否更新。 1. 什么是程序 计算机程序是 一组 指示电子计算机或其他具有消息处理能力设备每一步动作的 指令 。————《 维基百科：计算机程序 》…"},{"slug":"posts/code/ubuntu-apt-install-go","title":"Ubuntu使用apt安装最新版golang","content":"---\ntitle: \"Ubuntu使用apt安装最新版golang\"\ndate: 2020-12-09T21:42:29+08:00\ncategories: [\"code\"]\ntags: [\"apt\", \"ubuntu\", \"golang\"]\ndraft: false\n---\n\n\n### 1. 获取最新的软件包源，并添加至当前的apt库\n\n```cmd\nadd-apt-repository ppa:longsleep/golang-backports\n```\n\n如果没有 `add-apt-repository`\n\n```bash\nsudo apt-get install software-properties-common\n```\n\n### 2. 更新apt库\n\n```cmd\napt-get update\n```\n\n### 3. 安装go\n\n```cmd\nsudo apt-get install golang-go\n```\n","excerpt":"1. 获取最新的软件包源，并添加至当前的apt库 如果没有  add-apt-repository 2. 更新apt库 3. 安装go"},{"slug":"posts/code/vercel-draft","title":"解决Vercel部署Hugo时draft:true不生效，草稿也出现在博客中的问题。","content":"---\ntitle: \"解决Vercel部署Hugo时draft:true不生效，草稿也出现在博客中的问题。\"\ndate: 2020-12-18T09:56:26+08:00\ncategories: [\"code\"]\ntags: [\"vercel\", \"hugo\", \"draft\"]\ndraft: false\n---\n\n## 现象\n\n文章中设置了`draft: true`，本地`hugo server`不会看到该文章出现在本地调试的博客中，通过Vercel部署后文章出现在线上的站点中。\n\n## 原因\n\n> 有关Vercel对Hugo的处理，可以看看[这篇官方文章](https://vercel.com/guides/deploying-hugo-with-vercel)。\n\n打开Vercel项目的settings，可以看到`Build & Development Settings`下的hugo指令带有`-D`参数，这个参数会忽略draft这个标记，导致为编辑完的草稿也被编译、出现在博客中。\n\n## 解决\n\n|选项|值|\n|-|-|\n|BUILD COMMAND|hugo|\n\n开启`BUILD COMMAND`中的`OVERRIDE`按钮，手动修改编译命令，由于我的hugo没有其他额外的依赖，直接改成`hugo`，问题解决。\n","excerpt":"现象 文章中设置了 draft: true ，本地 hugo server 不会看到该文章出现在本地调试的博客中，通过Vercel部署后文章出现在线上的站点中。 原因 有关Vercel对Hugo的处理，可以看看 这篇官方文章 。 打开Vercel项目的settings，可以看到 Build & Development…"},{"slug":"posts/code/vercel-stop","title":"有关vercel部署的项目在一段时间空闲后会自动关闭的问题","content":"---\ntitle: \"有关vercel部署的项目在一段时间空闲后会自动关闭的问题\"\ndate: 2020-12-19T14:41:49+08:00\ndraft: false\ncategories: [\"code\"]\ntags: [\"serverless functions\",\"serverless\", \"vercel\", \"stateless\"]\n---\n\n## 现象\n\n通过vercel部署了Go的Serverless Functions，其中init函数中包含较长时间的初始化过程，每当一段时间不访问服务后的第一次访问总会很慢，猜测vercel是会将一段时间没人使用的服务关闭，等待该服务再次被请求时重新开启。\n\n## 验证\n\n如下的程序使用vercel部署后可以证明，当短时间连续请求多次时，接口返回的是\n\"11\"->\"111\"->\"1111\"，但一段时间没有请求时再请求，接口返回值会变回\"11\"。\n\n```go\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\nvar count = \"1\"\n\nfunc Handler(w http.ResponseWriter, r *http.Request) {\n    count += \"1\"\n    fmt.Fprintf(w, count)\n}\n```\n\n## 结论\n\n云函数对比传统开发模式而言多了一个\"装载\"的过程，即请求到达时，云函数先被装载到一个临时环境中，并在该环境中运行，为提高资源利用率，该云函数会继续占用该临时环境一段时间，以因对随后可能的连续请求（类似缓存原理），尽管此时云函数因为占有内存而在内部拥有保存运行状态的能力，但随着云函数空闲，云函数被移除该临时环境，对应的内存也会被清除回收，原先程序的运行数据将被不被保存，因此在编写云函数时应该保证该函数是无状态的，即每次请求之间应该不相互依赖，否则云函数将无法保证运行的结果能够符合预期。\n\n> 发现一篇有关这个问题的文章，写的很详尽，推荐：[万物皆可 Serverless 之关于云函数冷热启动那些事儿](https://blog.csdn.net/weixin_42409476/article/details/106789951)\n","excerpt":"现象 通过vercel部署了Go的Serverless Functions，其中init函数中包含较长时间的初始化过程，每当一段时间不访问服务后的第一次访问总会很慢，猜测vercel是会将一段时间没人使用的服务关闭，等待该服务再次被请求时重新开启。 验证 如下的程序使用vercel…"},{"slug":"posts/code/vscode-go","title":"解决VSCode开发Golang时无法保存的问题","content":"---\ntitle: \"解决VSCode开发Golang时无法保存的问题\"\ndate: 2020-12-18T20:54:11+08:00\ndraft: false\ntags: [\"vscode\", \"golang\", \"gopls\", \"proxy\", \"router\"]\ncategories: [\"code\"]\n---\n\n## 运行环境\n\n- 操作系统：macOS 10.15.6\n- Golang版本：go version go1.14.5 darwin/amd64\n- VSCode版本：1.52.1\n\n## 问题描述\n\n开发时启用gomodule、开启了gopls，在保存代码时频繁出现：\n\n> Saving 'main.go': Getting code actions from ''Go'' (configure)\n\n这不仅仅是没有代码提示、没有代码格式化的问题，连保存都无法生效，搜索了Google发现了在Github issues中有挺多关于这个问题的讨论和可以尝试的解决方案，这里给出几篇比较有参考价值的：\n\n- [https://github.com/microsoft/vscode-go/issues/3105](https://github.com/microsoft/vscode-go/issues/3105)\n- [https://github.com/microsoft/vscode-go/issues/3179](https://github.com/microsoft/vscode-go/issues/3179)\n- [https://github.com/golang/vscode-go/issues/236](https://github.com/golang/vscode-go/issues/236)\n\n## 问题解决\n\n很遗憾的是上面的链接中的方法我都有尝试，但是都没有效果，直到我看到了一条[回复](https://github.com/golang/vscode-go/issues/236#issuecomment-665753854)，原文如下：\n\n> I have a new discovery.\n> I also have the problem of Frequent pop-up on save: \"Getting code actions: Go, Go, ...\", I'm Chinese, so in our country,google is outside our great fire wall... I can't open google.com unless I use a proxy.\n> Today I opened vscode, the problem \"Getting code actions: Go, Go, ...\" came out as usual. I closed vscode and reopen it, the problem still there... After a few times reopening vscode, suddenly I find out that I'm not using proxy in vscode!!! So I turn on proxy, and, the miracle happen--the problem had gone, I can use gopls server fastly!!! All the things be OK!\n> Then After a few minutes, I closed vscode, and waited for some minutes. I reopened it, everything still working fine!!!\n\n简单概括一下就是他到了一个不需要科学上网的地方后，问题就消失了。\n\n我看到这条issues后，只是猜测当保存时会触发某种请求，请求的服务器可能无法在国内直连，并且有了一次请求成功后就不会再触发该请求了。但是因为我日常都挂着科学上网，理应不存在代理导致的问题，但是我又突然想起来一个问题，该请求是保存时触发的，而我的代理通常默认只对浏览器等会自动走代理的软件有效，特别是命令行终端就不会自动走代理（详见[如何让命令行终端的网络请求也走代理（未上线）]()），我突然想到其实VSCode里面自动触发的很多操作并不会走代理，我依然可能存在代理的问题。\n\n想到这里我就给我的路由器挂上了代理，因为路由器会将所有数据包做代理，但凡是网络请求就逃不过，这样就可以保证VSCode自动触发的那些命令也能被代理了。\n\n> A new version of gopls (v0.6.1) is available. Please update for an improved experience.\n\n结果是在我挂完代理后再打开VSCode编辑Golang代码、保存，我得到了一个gopls的更新提示，问我需不需要更新新版gopls，我选择了更新后一切使用正常，关掉路由器代理后一切也依旧正常，问题解决。\n","excerpt":"运行环境 操作系统：macOS 10.15.6 Golang版本：go version go1.14.5 darwin/amd64 VSCode版本：1.52.1 问题描述 开发时启用gomodule、开启了gopls，在保存代码时频繁出现： Saving 'main.go': Getting code actions…"},{"slug":"posts/draft/computer-history","title":"计算机操作系统历史","content":"---\ntitle: \"计算机操作系统历史\"\ndate: 2020-12-26T21:24:06+08:00\ndraft: true\n---\n\n> 内容源自《现代操作系统》第4版，第1章第2小节。\n\n时间回到 *1955* 年附近，那时候出现的机器现在被称作 **大型机（mainfram）**，锁在有专用空调的大房间里，由专业操作人员运行。要运行一个 **作业（job，即一个或一组程序）** ，程序员首先要将程序写在纸上（用FORTRAN语言或汇编语言），然后穿孔成 **卡片** ，再将卡片盒带到输入室，交给操作员，接着就喝咖啡直到输出完成。\n\n计算机运行完当前的任务后，其计算结果从打印机上输出，操作员到打印机上撕下运算结果并送到输出室，程序员稍后就可取到结果。\n\n在这个时期的机器不具备 **并发** 的能力，所有的 **作业** 都是一个一个被执行的，下一个作业需要等待上一个作业完成以后才能执行。也可以说，作业（或程序）在这个时期的机器上运行时是独占这整个机器的所有资源的，因为同一时间有且仅有一个作业能够被运行。\n\n当一个作业完成时，新的作业（卡片）需要被操作员手动换入机器才能被执行，在人工更换作业的时间内，机器处于空闲状态，这无疑是一种资源浪费（另一个背景是当时的机器**非常的昂贵**，只有少数大公司、重要的政府部门或大学能够接受百万美元的标价），为了提高机器的利用率，又引入了**批处理系统**。\n\n批处理系统的思想非常简单，既然人工更换太麻烦，那就一次性将很多的作业收集起来，一次执行一批作业。\n","excerpt":"内容源自《现代操作系统》第4版，第1章第2小节。 时间回到  1955  年附近，那时候出现的机器现在被称作  大型机（mainfram） ，锁在有专用空调的大房间里，由专业操作人员运行。要运行一个  作业（job，即一个或一组程序）  ，程序员首先要将程序写在纸上（用FORTRAN…"},{"slug":"posts/draft/daemon-commands","title":"Daemon Commands","content":"---\ntitle: \"Daemon Commands\"\ndate: 2020-12-28T14:45:29+08:00\ndraft: true\n---\n\nps -axj\n\n- -x 没有控制终端的进程\n- -a 显示其他用户\n- -j 显示与作业有关的信息：会话ID、进程组ID、控制终端以及控制进程组ID\n\n在基于System V的系统中，于此相关类似的命令是ps -efjc（为了提高安全性，某些UNIX系统不允许用户使用ps命令查看不属于自己的进程）。\n\n- PPID：父进程ID\n- PID：进程ID\n- PGID：进程组ID\n- SID：会话ID\n- TTY：终端名称\n- TPGID：终端进程组ID\n- UID：用户ID\n- TIME：累积CPU运行时间\n- COMMAND：命令字符串\n\n```bash\nroot@izwz98zwp24pi5mjf0bo9az ~                                                                       [14:43:54]\n> # ps -axj                                                                                                    \n PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND\n    0     1     1     1 ?           -1 Ss       0   1:06 /usr/lib/systemd/systemd --switched-root --system --des\n    0     2     0     0 ?           -1 S        0   0:00 [kthreadd]\n    2     3     0     0 ?           -1 S        0   3:59 [ksoftirqd/0]\n    2     5     0     0 ?           -1 S<       0   0:00 [kworker/0:0H]\n    2     7     0     0 ?           -1 S        0   0:00 [migration/0]\n    2     8     0     0 ?           -1 S        0   0:00 [rcu_bh]\n    2     9     0     0 ?           -1 R        0  69:10 [rcu_sched]\n    2    10     0     0 ?           -1 S        0   0:41 [watchdog/0]\n    2    12     0     0 ?           -1 S        0   0:00 [kdevtmpfs]\n    2    13     0     0 ?           -1 S<       0   0:00 [netns]\n    2    14     0     0 ?           -1 S        0   0:03 [khungtaskd]\n    2    15     0     0 ?           -1 S<       0   0:00 [writeback]\n    2    16     0     0 ?           -1 S<       0   0:00 [kintegrityd]\n    2    17     0     0 ?           -1 S<       0   0:00 [bioset]\n    2    18     0     0 ?           -1 S<       0   0:00 [kblockd]\n    2    19     0     0 ?           -1 S<       0   0:00 [md]\n    2    25     0     0 ?           -1 S        0   0:00 [kswapd0]\n    2    26     0     0 ?           -1 SN       0   0:00 [ksmd]\n    2    27     0     0 ?           -1 SN       0   0:19 [khugepaged]\n    2    28     0     0 ?           -1 S        0   0:00 [fsnotify_mark]\n    2    29     0     0 ?           -1 S<       0   0:00 [crypto]\n    2    37     0     0 ?           -1 S<       0   0:00 [kthrotld]\n    2    39     0     0 ?           -1 S<       0   0:00 [kmpath_rdacd]\n    2    40     0     0 ?           -1 S<       0   0:00 [kpsmoused]\n    2    41     0     0 ?           -1 S<       0   0:00 [ipv6_addrconf]\n    2    60     0     0 ?           -1 S<       0   0:00 [deferwq]\n    2    98     0     0 ?           -1 S        0   0:00 [kauditd]\n    2   216     0     0 ?           -1 S<       0   0:00 [ata_sff]\n    2   235     0     0 ?           -1 S        0   0:00 [scsi_eh_0]\n    2   236     0     0 ?           -1 S<       0   0:00 [scsi_tmf_0]\n    2   237     0     0 ?           -1 S        0   0:00 [scsi_eh_1]\n    2   238     0     0 ?           -1 S<       0   0:00 [scsi_tmf_1]\n    2   240     0     0 ?           -1 S<       0   0:00 [ttm_swap]\n    2   252     0     0 ?           -1 S<       0   0:55 [kworker/0:1H]\n    2   257     0     0 ?           -1 S        0   1:39 [jbd2/vda1-8]\n    2   258     0     0 ?           -1 S<       0   0:00 [ext4-rsv-conver]\n    1   327   327   327 ?           -1 Ss       0   0:28 /usr/lib/systemd/systemd-journald\n    1   351   351   351 ?           -1 Ss       0   0:00 /usr/sbin/lvmetad -f\n    1   354   354   354 ?           -1 Ss       0   0:00 /usr/lib/systemd/systemd-udevd\n    2   367     0     0 ?           -1 S        0   0:00 [vballoon]\n    1   428   428   428 ?           -1 S<sl     0   0:07 /sbin/auditd\n    1   448   448   448 ?           -1 Ssl      0 241:39 /usr/local/cloudmonitor/CmsGoAgent.linux-amd64\n    1   450   450   450 ?           -1 Ssl    998   0:18 /usr/lib/polkit-1/polkitd --no-debug\n    1   454   454   454 ?           -1 Ss      81   0:55 /usr/bin/dbus-daemon --system --address=systemd: --nofo\n    1   467   467   467 ?           -1 Ss       0   0:28 /usr/lib/systemd/systemd-logind\n    1   472   472   472 ?           -1 Ss       0   0:00 /usr/sbin/atd -f\n    1   473   473   473 ?           -1 Ss       0   0:16 /usr/sbin/crond -n\n    1   489   489   489 ttyS0      489 Ss+      0   0:00 /sbin/agetty --keep-baud 115200 38400 9600 ttyS0 vt220\n    1   490   490   490 tty1       490 Ss+      0   0:00 /sbin/agetty --noclear tty1 linux\n32661   607   607 32661 pts/0      607 R+       0   0:00 ps -axj\n    1   693   693   693 ?           -1 Ss       0   0:00 /sbin/dhclient -H izwz98zwp24pi5mjf0bo9az -1 -q -lf /va\n    1   754   754   754 ?           -1 Ssl      0  16:24 /usr/bin/python -Es /usr/sbin/tuned -l -P\n    1   760   760   760 ?           -1 Ssl      0   0:13 /usr/sbin/rsyslogd -n\n    1   781   781   781 ?           -1 Ss      38   0:43 /usr/sbin/ntpd -u ntp:ntp -g\n    1   897   897   897 ?           -1 Ssl   1001 453:19 ./ts3server inifile=ts3server.ini  daemon=1 pid_file=ts\n    1  1141  1139  1139 ?           -1 Sl     995 175:54 /usr/local/murmur/murmur.x86 -ini /etc/murmur.ini\n    1  2066  2066  2066 ?           -1 Ss       0   0:00 /usr/sbin/sshd -D\n    1  2108  2108  2108 ?           -1 Ssl      0 121:52 /usr/bin/dockerd-current --add-runtime docker-runc=/usr\n 2108  2118  2118  2118 ?           -1 Ssl      0  81:56 /usr/bin/docker-containerd-current -l unix:///var/run/d\n    1  2148  2146  2146 ?           -1 Sl      27  53:32 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld\n    1  2802  2778  2778 ?           -1 S<l      0  62:10 /usr/local/aegis/AliSecGuard/AliSecGuard\n    2  9672     0     0 ?           -1 S        0   0:05 [kworker/u2:0]\n    1 10217 10216  9480 ?           -1 Sl       0  20:04 java -jar halo-1.3.2.jar\n    2 11438     0     0 ?           -1 S        0   0:00 [kworker/0:1]\n    1 11443 11443 11443 ?           -1 Ss       0   0:00 nginx: master process /usr/sbin/nginx\n11443 11444 11443 11443 ?           -1 S      996   0:01 nginx: worker process\n    2 18209     0     0 ?           -1 S        0   0:00 [kworker/u2:1]\n    1 25227 25227 25227 ?           -1 Ssl    994 116:46 /usr/bin/redis-server 0.0.0.0:6379\n    1 25395 25395 24625 ?           -1 SNl      0   2:17 ./ssr-sub-hub\n    1 27149 27149 27149 ?           -1 Ssl      0  10:07 /usr/local/share/assist-daemon/assist_daemon\n    1 27183 27183 27183 ?           -1 Ssl      0   9:27 /usr/sbin/aliyun-service\n    1 29128 29128 29128 ?           -1 S<sl     0   4:40 /usr/local/aegis/aegis_update/AliYunDunUpdate\n    1 29145 29145 29145 ?           -1 S<sl     0 102:41 /usr/local/aegis/aegis_client/aegis_10_89/AliYunDun\n    2 31039     0     0 ?           -1 R        0   0:03 [kworker/0:0]\n 2066 32659 32659 32659 ?           -1 Ss       0   0:00 sshd: root@pts/0\n32659 32661 32661 32661 pts/0      607 Rs       0   0:00 zsh\n```\n```bash\njabin@ubuntu:~$ ps -ajx\n PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND\n    0     1     1     1 ?           -1 Ss       0   0:00 /sbin/init\n    0     2     0     0 ?           -1 S        0   0:00 [kthreadd]\n    2     3     0     0 ?           -1 S        0   0:00 [ksoftirqd/0]\n    2     4     0     0 ?           -1 S        0   0:00 [kworker/0:0]\n    2     5     0     0 ?           -1 S<       0   0:00 [kworker/0:0H]\n    2     6     0     0 ?           -1 S        0   0:00 [kworker/u64:0]\n    2     7     0     0 ?           -1 S        0   0:00 [rcu_sched]\n    2     8     0     0 ?           -1 S        0   0:00 [rcuos/0]\n    2     9     0     0 ?           -1 S        0   0:00 [rcuos/1]\n    2    10     0     0 ?           -1 S        0   0:00 [rcuos/2]\n    2    11     0     0 ?           -1 S        0   0:00 [rcuos/3]\n    2    12     0     0 ?           -1 S        0   0:00 [rcuos/4]\n    2    13     0     0 ?           -1 S        0   0:00 [rcuos/5]\n    2    14     0     0 ?           -1 S        0   0:00 [rcuos/6]\n    2    15     0     0 ?           -1 S        0   0:00 [rcuos/7]\n    2    16     0     0 ?           -1 S        0   0:00 [rcuos/8]\n    2    17     0     0 ?           -1 S        0   0:00 [rcuos/9]\n    2    18     0     0 ?           -1 S        0   0:00 [rcuos/10]\n    2    19     0     0 ?           -1 S        0   0:00 [rcuos/11]\n    2    20     0     0 ?           -1 S        0   0:00 [rcuos/12]\n    2    21     0     0 ?           -1 S        0   0:00 [rcuos/13]\n    2    22     0     0 ?           -1 S        0   0:00 [rcuos/14]\n    2    23     0     0 ?           -1 S        0   0:00 [rcuos/15]\n    2    24     0     0 ?           -1 S        0   0:00 [rcuos/16]\n    2    25     0     0 ?           -1 S        0   0:00 [rcuos/17]\n    2    26     0     0 ?           -1 S        0   0:00 [rcuos/18]\n    2    27     0     0 ?           -1 S        0   0:00 [rcuos/19]\n    2    28     0     0 ?           -1 S        0   0:00 [rcuos/20]\n    2    29     0     0 ?           -1 S        0   0:00 [rcuos/21]\n    2    30     0     0 ?           -1 S        0   0:00 [rcuos/22]\n    2    31     0     0 ?           -1 S        0   0:00 [rcuos/23]\n    2    32     0     0 ?           -1 S        0   0:00 [rcuos/24]\n    2    33     0     0 ?           -1 S        0   0:00 [rcuos/25]\n    2    34     0     0 ?           -1 S        0   0:00 [rcuos/26]\n    2    35     0     0 ?           -1 S        0   0:00 [rcuos/27]\n    2    36     0     0 ?           -1 S        0   0:00 [rcuos/28]\n    2    37     0     0 ?           -1 S        0   0:00 [rcuos/29]\n    2    38     0     0 ?           -1 S        0   0:00 [rcuos/30]\n    2    39     0     0 ?           -1 S        0   0:00 [rcuos/31]\n    2    40     0     0 ?           -1 S        0   0:00 [rcu_bh]\n    2    41     0     0 ?           -1 S        0   0:00 [rcuob/0]\n    2    42     0     0 ?           -1 S        0   0:00 [rcuob/1]\n    2    43     0     0 ?           -1 S        0   0:00 [rcuob/2]\n    2    44     0     0 ?           -1 S        0   0:00 [rcuob/3]\n    2    45     0     0 ?           -1 S        0   0:00 [rcuob/4]\n    2    46     0     0 ?           -1 S        0   0:00 [rcuob/5]\n    2    47     0     0 ?           -1 S        0   0:00 [rcuob/6]\n    2    48     0     0 ?           -1 S        0   0:00 [rcuob/7]\n    2    49     0     0 ?           -1 S        0   0:00 [rcuob/8]\n    2    50     0     0 ?           -1 S        0   0:00 [rcuob/9]\n    2    51     0     0 ?           -1 S        0   0:00 [rcuob/10]\n    2    52     0     0 ?           -1 S        0   0:00 [rcuob/11]\n    2    53     0     0 ?           -1 S        0   0:00 [rcuob/12]\n    2    54     0     0 ?           -1 S        0   0:00 [rcuob/13]\n    2    55     0     0 ?           -1 S        0   0:00 [rcuob/14]\n    2    56     0     0 ?           -1 S        0   0:00 [rcuob/15]\n    2    57     0     0 ?           -1 S        0   0:00 [rcuob/16]\n    2    58     0     0 ?           -1 S        0   0:00 [rcuob/17]\n    2    59     0     0 ?           -1 S        0   0:00 [rcuob/18]\n    2    60     0     0 ?           -1 S        0   0:00 [rcuob/19]\n    2    61     0     0 ?           -1 S        0   0:00 [rcuob/20]\n    2    62     0     0 ?           -1 S        0   0:00 [rcuob/21]\n    2    63     0     0 ?           -1 S        0   0:00 [rcuob/22]\n    2    64     0     0 ?           -1 S        0   0:00 [rcuob/23]\n    2    65     0     0 ?           -1 S        0   0:00 [rcuob/24]\n    2    66     0     0 ?           -1 S        0   0:00 [rcuob/25]\n    2    67     0     0 ?           -1 S        0   0:00 [rcuob/26]\n    2    68     0     0 ?           -1 S        0   0:00 [rcuob/27]\n    2    69     0     0 ?           -1 S        0   0:00 [rcuob/28]\n    2    70     0     0 ?           -1 S        0   0:00 [rcuob/29]\n    2    71     0     0 ?           -1 S        0   0:00 [rcuob/30]\n    2    72     0     0 ?           -1 S        0   0:00 [rcuob/31]\n    2    73     0     0 ?           -1 S        0   0:00 [migration/0]\n    2    74     0     0 ?           -1 S        0   0:00 [watchdog/0]\n    2    75     0     0 ?           -1 S        0   0:00 [watchdog/1]\n    2    76     0     0 ?           -1 S        0   0:00 [migration/1]\n    2    77     0     0 ?           -1 S        0   0:00 [ksoftirqd/1]\n    2    78     0     0 ?           -1 S        0   0:00 [kworker/1:0]\n    2    79     0     0 ?           -1 S<       0   0:00 [kworker/1:0H]\n    2    80     0     0 ?           -1 S<       0   0:00 [khelper]\n    2    81     0     0 ?           -1 S        0   0:00 [kdevtmpfs]\n    2    82     0     0 ?           -1 S<       0   0:00 [netns]\n    2    83     0     0 ?           -1 S<       0   0:00 [writeback]\n    2    84     0     0 ?           -1 S<       0   0:00 [kintegrityd]\n    2    85     0     0 ?           -1 S<       0   0:00 [bioset]\n    2    86     0     0 ?           -1 S<       0   0:00 [kworker/u65:0]\n    2    87     0     0 ?           -1 S<       0   0:00 [kblockd]\n    2    88     0     0 ?           -1 S<       0   0:00 [ata_sff]\n    2    89     0     0 ?           -1 S        0   0:00 [khubd]\n    2    90     0     0 ?           -1 S<       0   0:00 [md]\n    2    91     0     0 ?           -1 S<       0   0:00 [devfreq_wq]\n    2    92     0     0 ?           -1 S        0   0:00 [kworker/0:1]\n    2    93     0     0 ?           -1 S        0   0:00 [kworker/1:1]\n    2    95     0     0 ?           -1 S        0   0:00 [khungtaskd]\n    2    96     0     0 ?           -1 S        0   0:00 [kswapd0]\n    2    97     0     0 ?           -1 SN       0   0:00 [ksmd]\n    2    98     0     0 ?           -1 SN       0   0:00 [khugepaged]\n    2    99     0     0 ?           -1 S        0   0:00 [fsnotify_mark]\n    2   100     0     0 ?           -1 S        0   0:00 [ecryptfs-kthrea]\n    2   101     0     0 ?           -1 S<       0   0:00 [crypto]\n    2   113     0     0 ?           -1 S<       0   0:00 [kthrotld]\n    2   114     0     0 ?           -1 S        0   0:00 [kworker/u64:1]\n    2   115     0     0 ?           -1 S        0   0:00 [vballoon]\n    2   116     0     0 ?           -1 S        0   0:00 [scsi_eh_0]\n    2   117     0     0 ?           -1 S        0   0:00 [scsi_eh_1]\n    2   118     0     0 ?           -1 S        0   0:00 [kworker/u64:2]\n    2   119     0     0 ?           -1 S        0   0:00 [kworker/u64:3]\n    2   138     0     0 ?           -1 S<       0   0:00 [deferwq]\n    2   139     0     0 ?           -1 S<       0   0:00 [charger_manager]\n    2   140     0     0 ?           -1 S        0   0:00 [kworker/1:2]\n    2   180     0     0 ?           -1 S        0   0:00 [scsi_eh_2]\n    2   188     0     0 ?           -1 S        0   0:00 [scsi_eh_3]\n    2   189     0     0 ?           -1 S        0   0:00 [scsi_eh_4]\n    2   190     0     0 ?           -1 S        0   0:00 [scsi_eh_5]\n    2   191     0     0 ?           -1 S        0   0:00 [scsi_eh_6]\n    2   192     0     0 ?           -1 S        0   0:00 [scsi_eh_7]\n    2   193     0     0 ?           -1 S        0   0:00 [kworker/u64:4]\n    2   194     0     0 ?           -1 S        0   0:00 [kworker/u64:5]\n    2   195     0     0 ?           -1 S        0   0:00 [kworker/u64:6]\n    2   196     0     0 ?           -1 S        0   0:00 [kworker/u64:7]\n    2   197     0     0 ?           -1 S        0   0:00 [kworker/u64:8]\n    2   211     0     0 ?           -1 S        0   0:00 [jbd2/sda1-8]\n    2   212     0     0 ?           -1 S<       0   0:00 [ext4-rsv-conver]\n    2   320     0     0 ?           -1 S<       0   0:00 [kworker/u65:1]\n    1   371   369   369 ?           -1 S        0   0:00 upstart-udev-bridge --daemon\n    1   379   379   379 ?           -1 Ss       0   0:00 /lib/systemd/systemd-udevd --daemon\n    1   459   459   459 ?           -1 Ss     102   0:00 dbus-daemon --system --fork\n    1   489   489   489 ?           -1 Ss       0   0:00 /usr/sbin/bluetoothd\n    1   494   494   494 ?           -1 Ss       0   0:00 /lib/systemd/systemd-logind\n    1   501   501   501 ?           -1 Ssl    101   0:00 rsyslogd\n    2   510     0     0 ?           -1 S        0   0:00 [kworker/0:2]\n    2   517     0     0 ?           -1 S<       0   0:00 [krfcommd]\n    2   521     0     0 ?           -1 S<       0   0:00 [kpsmoused]\n    1   538   531   531 ?           -1 S      111   0:00 avahi-daemon: running [ubuntu.local]\n  538   543   531   531 ?           -1 S      111   0:00 avahi-daemon: chroot helper\n    1   567   565   565 ?           -1 S        0   0:00 upstart-file-bridge --daemon\n    1   676   676   676 ?           -1 Ssl      0   0:00 /usr/sbin/ModemManager\n    1   738   737   737 ?           -1 S        0   0:00 upstart-socket-bridge --daemon\n    2   742     0     0 ?           -1 S<       0   0:00 [hd-audio0]\n    1   753   753   753 ?           -1 Ssl      0   0:00 NetworkManager\n    1   775   459   459 ?           -1 Sl       0   0:00 /usr/lib/policykit-1/polkitd --no-debug\n  753   816   816   753 ?           -1 S        0   0:00 /sbin/dhclient -d -sf /usr/lib/NetworkManager/nm-dhcp-client.action -\n    1   854   854   854 ?           -1 Ssl      0   0:00 /usr/bin/prltoolsd -p /var/run/prltoolsd.pid\n  854   939   854   854 ?           -1 Sl       0   0:00 prlshprint\n  854   940   854   854 ?           -1 S        0   0:00 prltimesync\n  854   941   854   854 ?           -1 Sl       0   0:00 prlusmd\n    1   977   977   977 tty4       977 Ss+      0   0:00 /sbin/getty -8 38400 tty4\n    1   987   987   987 tty5       987 Ss+      0   0:00 /sbin/getty -8 38400 tty5\n    1   996   996   996 tty2       996 Ss+      0   0:00 /sbin/getty -8 38400 tty2\n    1   998   998   998 tty3       998 Ss+      0   0:00 /sbin/getty -8 38400 tty3\n    1  1005  1005  1005 tty6      1005 Ss+      0   0:00 /sbin/getty -8 38400 tty6\n    1  1091  1091  1091 ?           -1 Ss       0   0:00 anacron -s\n    1  1093  1093  1093 ?           -1 Ss     106   0:00 /usr/sbin/kerneloops\n    1  1095  1095  1095 ?           -1 Ss       0   0:00 cron\n    1  1127  1127  1127 ?           -1 Ssl    109   0:00 whoopsie\n    1  1206  1206  1206 ?           -1 Ss       0   0:00 /usr/sbin/irqbalance\n    1  1295  1295  1295 tty1      1295 Ss+      0   0:00 /sbin/getty -8 38400 tty1\n    1  1359  1359  1359 ?           -1 SLsl     0   0:00 lightdm\n    1  1370  1370  1370 ?           -1 Ss       0   0:00 /usr/sbin/cups-browsed\n    2  1398     0     0 ?           -1 S        0   0:00 [kauditd]\n    1  1401  1401  1401 ?           -1 Ss       0   0:00 acpid -c /etc/acpi/events -s /var/run/acpid.socket\n 1359  1403  1403  1403 tty7      1403 Ssl+     0   0:19 /usr/bin/X -core :0 -seat seat0 -auth /var/run/lightdm/root/:0 -nolis\n    1  1406   459   459 ?           -1 Sl       0   0:00 /usr/lib/accountsservice/accounts-daemon\n  753  1418  1418   753 ?           -1 S    65534   0:00 /usr/sbin/dnsmasq --no-resolv --keep-in-foreground --no-hosts --bind-\n 1359  1621  1359  1359 ?           -1 Sl       0   0:00 lightdm --session-child 12 19\n    1  1646   459   459 ?           -1 Sl       0   0:00 /usr/lib/upower/upowerd\n    1  1712   459   459 ?           -1 SNl    107   0:00 /usr/lib/rtkit/rtkit-daemon\n    1  1803   459   459 ?           -1 Sl     113   0:00 /usr/lib/colord/colord\n    1  1946  1945  1945 ?           -1 Sl    1000   0:00 /usr/bin/gnome-keyring-daemon --daemonize --login\n 1621  1948  1948  1948 ?           -1 Ss    1000   0:00 init --user\n    1  2003  1948  1948 ?           -1 S     1000   0:00 dbus-launch --autolaunch=dcf54b3aafd9cb105317c9545fe9b43a --binary-sy\n    1  2006  2006  2006 ?           -1 Ss    1000   0:00 //bin/dbus-daemon --fork --print-pid 5 --print-address 7 --session\n 1948  2018  2018  2018 ?           -1 Ss    1000   0:00 ssh-agent\n 1948  2025  2025  2025 ?           -1 Ss    1000   0:00 dbus-daemon --fork --session --address=unix:abstract=/tmp/dbus-sn9KW8\n 1948  2033  2033  2033 ?           -1 Ss    1000   0:00 upstart-event-bridge\n 1948  2035  2035  2035 ?           -1 Ss    1000   0:00 /usr/lib/x86_64-linux-gnu/hud/window-stack-bridge\n 1948  2053  2025  2025 ?           -1 Sl    1000   0:00 /usr/lib/x86_64-linux-gnu/bamf/bamfdaemon\n 1948  2057  2057  2057 ?           -1 Rsl   1000   0:00 /usr/bin/ibus-daemon --daemonize --xim\n 1948  2062  2025  2025 ?           -1 Sl    1000   0:00 /usr/lib/at-spi2-core/at-spi-bus-launcher\n 1948  2068  2066  2066 ?           -1 S     1000   0:00 upstart-file-bridge --daemon --user\n 1948  2072  2067  2067 ?           -1 S     1000   0:00 upstart-dbus-bridge --daemon --session --user --bus-name session\n 1948  2074  2073  2073 ?           -1 S     1000   0:00 upstart-dbus-bridge --daemon --system --user --bus-name system\n 1948  2081  2081  2081 ?           -1 Ssl   1000   0:00 /usr/lib/unity-settings-daemon/unity-settings-daemon\n 1948  2087  2025  2025 ?           -1 Sl    1000   0:00 /usr/lib/gvfs/gvfsd\n 1948  2088  2088  2088 ?           -1 Ssl   1000   0:00 /usr/lib/x86_64-linux-gnu/hud/hud-service\n 1948  2094  2094  2094 ?           -1 Ssl   1000   0:00 gnome-session --session=ubuntu\n 2062  2098  2025  2025 ?           -1 S     1000   0:00 /bin/dbus-daemon --config-file=/etc/at-spi2/accessibility.conf --nofo\n 1948  2100  2100  2100 ?           -1 Ssl   1000   0:00 /usr/lib/unity/unity-panel-service\n 1948  2108  2093  2093 ?           -1 Sl    1000   0:00 /usr/lib/at-spi2-core/at-spi2-registryd --use-gnome-session\n 1948  2117  2025  2025 ?           -1 Sl    1000   0:00 /usr/lib/gvfs/gvfsd-fuse /run/user/1000/gvfs -f -o big_writes\n 2057  2128  2057  2057 ?           -1 Sl    1000   0:00 /usr/lib/ibus/ibus-dconf\n 2057  2130  2057  2057 ?           -1 Sl    1000   0:00 /usr/lib/ibus/ibus-ui-gtk3\n 1948  2141  2057  2057 ?           -1 Sl    1000   0:00 /usr/lib/ibus/ibus-x11 --kill-daemon\n 1948  2151  2025  2025 ?           -1 Sl    1000   0:00 /usr/lib/at-spi2-core/at-spi2-registryd --use-gnome-session\n 1948  2160  2147  2147 ?           -1 Sl    1000   0:00 /usr/lib/at-spi2-core/at-spi2-registryd --use-gnome-session\n 1948  2195  2195  2195 ?           -1 Ssl   1000   0:00 /usr/lib/x86_64-linux-gnu/indicator-messages/indicator-messages-servi\n 1948  2201  2201  2201 ?           -1 Ssl   1000   0:00 /usr/lib/x86_64-linux-gnu/indicator-bluetooth/indicator-bluetooth-ser\n 1948  2203  2203  2203 ?           -1 Ssl   1000   0:00 /usr/lib/x86_64-linux-gnu/indicator-power/indicator-power-service\n 1948  2205  2205  2205 ?           -1 Ssl   1000   0:00 /usr/lib/x86_64-linux-gnu/indicator-datetime/indicator-datetime-servi\n 1948  2206  2206  2206 ?           -1 Ssl   1000   0:00 /usr/lib/x86_64-linux-gnu/indicator-sound/indicator-sound-service\n 1948  2212  2212  2212 ?           -1 Ssl   1000   0:00 /usr/lib/x86_64-linux-gnu/indicator-printers/indicator-printers-servi\n 1948  2216  2216  2216 ?           -1 Ssl   1000   0:00 /usr/lib/x86_64-linux-gnu/indicator-session/indicator-session-service\n 1948  2239  2025  2025 ?           -1 Sl    1000   0:00 /usr/lib/x86_64-linux-gnu/indicator-keyboard-service --use-gtk\n 1948  2240  2240  2240 ?           -1 Ssl   1000   0:00 /usr/lib/x86_64-linux-gnu/indicator-application/indicator-application\n 1948  2257  2256  2256 ?           -1 S<l   1000   0:00 /usr/bin/pulseaudio --start --log-target=syslog\n 1948  2278  2025  2025 ?           -1 Sl    1000   0:00 /usr/lib/evolution/evolution-source-registry\n 2057  2297  2057  2057 ?           -1 Sl    1000   0:00 /usr/lib/ibus/ibus-engine-simple\n 1948  2334  2025  2025 ?           -1 Sl    1000   0:00 /usr/lib/x86_64-linux-gnu/notify-osd\n    1  2342   459   459 ?           -1 S        0   0:00 /lib/systemd/systemd-localed\n 1948  2351  2025  2025 ?           -1 Sl    1000   0:00 /usr/lib/dconf/dconf-service\n 2094  2358  2094  2094 ?           -1 Rl    1000   0:10 compiz\n 2094  2392  2094  2094 ?           -1 Sl    1000   0:00 /usr/lib/unity-settings-daemon/unity-fallback-mount-helper\n 2094  2402  2094  2094 ?           -1 Sl    1000   0:00 /usr/lib/policykit-1-gnome/polkit-gnome-authentication-agent-1\n 2094  2407  2094  2094 ?           -1 Sl    1000   0:05 nautilus -n\n 2094  2426  2094  2094 ?           -1 Sl    1000   0:00 nm-applet\n 2094  2432  2094  2094 ?           -1 Sl    1000   0:02 /usr/bin/prlcc\n 2432  2435  2094  2094 ?           -1 Sl    1000   0:00 /usr/bin/prldnd\n 2432  2436  2094  2094 ?           -1 Sl    1000   0:00 /usr/bin/prlcp\n 2432  2437  2094  2094 ?           -1 Sl    1000   0:00 /usr/bin/prlsga\n 2432  2438  2094  2094 ?           -1 S     1000   0:00 /usr/bin/prlshprof\n 1948  2453  2025  2025 ?           -1 Sl    1000   0:00 /usr/lib/evolution/evolution-calendar-factory\n 1948  2525  2025  2025 ?           -1 Sl    1000   0:00 /usr/lib/gvfs/gvfs-udisks2-volume-monitor\n    1  2532   459   459 ?           -1 Sl       0   0:00 /usr/lib/udisks2/udisksd --no-debug\n 1948  2578  2025  2025 ?           -1 S     1000   0:00 /usr/lib/x86_64-linux-gnu/gconf/gconfd-2\n 1948  2614  2025  2025 ?           -1 Sl    1000   0:00 /usr/lib/gvfs/gvfsd-metadata\n 1948  2619  2025  2025 ?           -1 Sl    1000   0:00 /usr/lib/gvfs/gvfs-mtp-volume-monitor\n 1948  2625  2025  2025 ?           -1 Sl    1000   0:00 /usr/lib/gvfs/gvfs-gphoto2-volume-monitor\n 1948  2633  2025  2025 ?           -1 Sl    1000   0:00 /usr/lib/gvfs/gvfs-afc-volume-monitor\n 1948  2667  2025  2025 ?           -1 Sl    1000   0:00 /usr/lib/gvfs/gvfsd-trash --spawner :1.7 /org/gtk/gvfs/exec_spaw/0\n 1948  2687  2025  2025 ?           -1 Sl    1000   0:00 /usr/lib/gvfs/gvfsd-burn --spawner :1.7 /org/gtk/gvfs/exec_spaw/1\n 2094  2760  2094  2094 ?           -1 Sl    1000   0:00 telepathy-indicator\n 1948  2768  2025  2025 ?           -1 Sl    1000   0:00 /usr/lib/telepathy/mission-control-5\n    1  2792   459   459 ?           -1 S        0   0:00 /lib/systemd/systemd-hostnamed\n 2094  2798  2094  2094 ?           -1 Sl    1000   0:00 zeitgeist-datahub\n 1948  2804  2025  2025 ?           -1 Sl    1000   0:00 /usr/bin/zeitgeist-daemon\n 1948  2812  2025  2025 ?           -1 Sl    1000   0:00 /usr/lib/x86_64-linux-gnu/zeitgeist-fts\n 2812  2822  2025  2025 ?           -1 S     1000   0:00 /bin/cat\n    1  2834  2834  2834 ?           -1 Ss       0   0:00 /usr/sbin/cupsd -f\n 2834  2837  2837  2834 ?           -1 S        7   0:00 /usr/lib/cups/notifier/dbus dbus://\n 2094  3044  2094  2094 ?           -1 Sl    1000   0:00 update-notifier\n 1948  3078  2094  2094 ?           -1 SNl   1000   0:05 /usr/bin/python3 /usr/bin/update-manager --no-update --no-focus-on-ma\n 1948  3146  2025  2025 ?           -1 Sl    1000   0:00 /usr/lib/x86_64-linux-gnu/unity-scope-home/unity-scope-home\n 1948  3161  2025  2025 ?           -1 Sl    1000   0:00 /usr/lib/x86_64-linux-gnu/unity-lens-files/unity-files-daemon\n 1948  3162  2025  2025 ?           -1 Sl    1000   0:00 /usr/bin/unity-scope-loader applications/applications.scope applicati\n 1948  3232  2025  2025 ?           -1 Sl    1000   0:00 /usr/bin/python /usr/share/software-center/software-center-dbus\n 1948  3245  2025  2025 ?           -1 Sl    1000   0:00 /usr/lib/geoclue/geoclue-master\n 1948  3249  2025  2025 ?           -1 Sl    1000   0:00 /usr/lib/x86_64-linux-gnu/ubuntu-geoip-provider\n 1948  3277  2094  2094 ?           -1 Sl    1000   0:05 gnome-terminal\n 3277  3286  2094  2094 ?           -1 S     1000   0:00 gnome-pty-helper\n 3277  3287  3287  3287 pts/0     3931 Ss    1000   0:00 bash\n 2094  3420  2094  2094 ?           -1 Sl    1000   0:00 /usr/lib/x86_64-linux-gnu/deja-dup/deja-dup-monitor\n 3287  3931  3931  3287 pts/0     3931 R+    1000   0:00 ps -ajx\njabin@ubuntu:~$\n```\n\n安装一个Nginx服务器\n\n```bash\njabin@ubuntu:~$ sudo apt-get install nginx\nReading package lists... Done\nBuilding dependency tree       \nReading state information... Done\nThe following extra packages will be installed:\n  nginx-common nginx-core\nSuggested packages:\n  fcgiwrap nginx-doc\nThe following NEW packages will be installed:\n  nginx nginx-common nginx-core\n0 upgraded, 3 newly installed, 0 to remove and 763 not upgraded.\nNeed to get 349 kB of archives.\nAfter this operation, 1,300 kB of additional disk space will be used.\nDo you want to continue? [Y/n] Y\nGet:1 http://us.archive.ubuntu.com/ubuntu/ trusty-updates/main nginx-common all 1.4.6-1ubuntu3.9 [18.9 kB]\nGet:2 http://us.archive.ubuntu.com/ubuntu/ trusty-updates/main nginx-core amd64 1.4.6-1ubuntu3.9 [325 kB]\nGet:3 http://us.archive.ubuntu.com/ubuntu/ trusty-updates/main nginx all 1.4.6-1ubuntu3.9 [5,418 B]\nFetched 349 kB in 2s (167 kB/s)\nPreconfiguring packages ...\nSelecting previously unselected package nginx-common.\n(Reading database ... 163411 files and directories currently installed.)\nPreparing to unpack .../nginx-common_1.4.6-1ubuntu3.9_all.deb ...\nUnpacking nginx-common (1.4.6-1ubuntu3.9) ...\nSelecting previously unselected package nginx-core.\nPreparing to unpack .../nginx-core_1.4.6-1ubuntu3.9_amd64.deb ...\nUnpacking nginx-core (1.4.6-1ubuntu3.9) ...\nSelecting previously unselected package nginx.\nPreparing to unpack .../nginx_1.4.6-1ubuntu3.9_all.deb ...\nUnpacking nginx (1.4.6-1ubuntu3.9) ...\nProcessing triggers for ureadahead (0.100.0-16) ...\nureadahead will be reprofiled on next reboot\nProcessing triggers for ufw (0.34~rc-0ubuntu2) ...\nProcessing triggers for man-db (2.6.7.1-1) ...\nSetting up nginx-common (1.4.6-1ubuntu3.9) ...\nProcessing triggers for ureadahead (0.100.0-16) ...\nProcessing triggers for ufw (0.34~rc-0ubuntu2) ...\nSetting up nginx-core (1.4.6-1ubuntu3.9) ...\nSetting up nginx (1.4.6-1ubuntu3.9) ...\njabin@ubuntu:~$\n```\n\n```bash\njabin@ubuntu:~$ curl http://localhost\n<!DOCTYPE html>\n<html>\n<head>\n<title>Welcome to nginx!</title>\n<style>\n    body {\n        width: 35em;\n        margin: 0 auto;\n        font-family: Tahoma, Verdana, Arial, sans-serif;\n    }\n</style>\n</head>\n<body>\n<h1>Welcome to nginx!</h1>\n<p>If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.</p>\n\n<p>For online documentation and support please refer to\n<a href=\"http://nginx.org/\">nginx.org</a>.<br/>\nCommercial support is available at\n<a href=\"http://nginx.com/\">nginx.com</a>.</p>\n\n<p><em>Thank you for using nginx.</em></p>\n</body>\n</html>\njabin@ubuntu:~$\n```\n","excerpt":"ps -axj -x 没有控制终端的进程 -a 显示其他用户 -j 显示与作业有关的信息：会话ID、进程组ID、控制终端以及控制进程组ID 在基于System V的系统中，于此相关类似的命令是ps -efjc（为了提高安全性，某些UNIX系统不允许用户使用ps命令查看不属于自己的进程）。 PPID：父进程ID PID…"},{"slug":"posts/draft/daemon-process","title":"操作系统系列之——守护进程","content":"---\ntitle: \"操作系统系列之——守护进程\"\ndate: 2020-12-22T21:24:06+08:00\ntags: [\"os\", \"procedure\", \"process\", \"unix-like\", \"c\"]\ncategories: [\"code\"]\ndraft: true\n---\n\n> 本文要求你对进程有一定概念。如果不懂什么是进程，推荐你查看我的文章[操作系统系列之——程序](http://localhost:1313/posts/code/os-program/)和[操作系统系列之——进程](http://localhost:1313/posts/code/os-process/)。\n\n## 1. 概念解释\n\n**守护进程**（*Daemon Process*），是一种 **不被用户直接控制的** 、 **运行在后台** 的进程。通常而言守护进程的进程名称会以 *字母d* 结尾，用以表明该进程是一个不同于普通进程的守护进程。\n\n## 1.1. Daemon一词的起源\n\n*Daemon*源自古典拉丁语，表示**具有掌管能力的灵体**。\n\n该词曾被科学家 **詹姆斯·麦克斯韦** 引用于一个“思想实验”中，他想象在一个被分隔为两部分的封闭容器中间，存在一个大小仅仅够一个气体分子通过的门。这道门，由一个想象中的掌管精灵Daemon控制。这个掌管精灵Daemon根据气体的速度，只让速度快(温度高)的气体分子由A半到B半，也只让速度慢(温度低)的气体由B半到A半。最终这个封闭容器将一半冷一半热。麦克斯韦的这个想法因为脱离了热力学原理而轰动一时，但最终量子力学理论证明了其不可能性。\n\n随后在1963年运行于`IBM 7094`系统上的`Project MAC`项目中，具有物理学背景的 *Jerome H. Saltzer* 教授用麦克斯韦实验中那个不断看管着分子的掌管精灵，来指代**不懈地工作**来执行系统琐事的**后台进程**，这是*Daemon*一词首次出现在计算机世界。\n\n\n## 2. 守护进程有哪些特点\n\n让我们通过一个实际运作着的Linux中的进程信息来得到守护进程的特点，这里选择大家都比较熟悉的 *Ubuntu* 系统，版本为 *14.04*（选这个版本是有原因的，后面再说到这个问题）。\n\n为了便于演示，我直接用虚拟机新装了一个系统，系统起初只有装机默认的程序。\n\n### 2.1. 安装Nginx\n\n首先我们装一个 *Nginx* (如果你没接触过的话，简单的讲它就是一个类似 *Apache* 的 *HTTP* 服务器），通过系统的 *Terminal* 执行命令 `sudo apt-get install nginx` 即可。安装完成后，*apt* 包管理会自动配置好 *Nginx的守护进程* ，它将会被启动并且设置为开机自启。\n\n*Nginx* 会默认运行在 *80* 端口（这是使用浏览器访问网站时的默认端口），因此我们可以在本机使用浏览器访问 *http://localhost* 来测试 *Nginx* 是否已经成功启动，但是由于我装的系统是 **服务器版本** 没有 **gui界面** ，只有命令行可用，因此这里使用 *curl* 命令来代替浏览器测试。\n\n在机器上执行`curl http://localhost`，该命令将产生类似浏览器访问 *http://localhost* 的效果，不同的是结果将以 *html源代码* 的形式输出在 *Terminal* 而不是显示 *html源代码*  **渲染后的网页** 。\n\n以下是 `curl http://localhost` 执行结果，这是 *Nginx* 默认的 **欢迎页** ：\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<title>Welcome to nginx!</title>\n<style>\n    body {\n        width: 35em;\n        margin: 0 auto;\n        font-family: Tahoma, Verdana, Arial, sans-serif;\n    }\n</style>\n</head>\n<body>\n<h1>Welcome to nginx!</h1>\n<p>If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.</p>\n\n<p>For online documentation and support please refer to\n<a href=\"http://nginx.org/\">nginx.org</a>.<br/>\nCommercial support is available at\n<a href=\"http://nginx.com/\">nginx.com</a>.</p>\n\n<p><em>Thank you for using nginx.</em></p>\n</body>\n</html>\n```\n\n### 2.2. 安装SSH\n\n因为虚拟机没有gui界面，命令的结果不好复制出来，因此希望通过本机ssh连接该电脑，执行命令并复制命令结果。\n\n系统默认只安装了 *ssh* 的客户端 *openssh-client*，因而无法提供ssh服务让其他电脑连接，为了能够让其他电脑能够使用 *ssh* 从远程连接这台电脑，通常都会安装 *ssh* 的服务端 *openssh-server*，同样使用一行命令即可 `sudo apt-get install openssh-server`。\n\n与 *Nginx* 安装过程一样，命令执行完成后系统中就已经配置好了 *ssh* 相关的守护进程了，通常它名为 *sshd*。验证方法也很简单，用另一台电脑通过 *ssh* 连接即可。\n\n值的一提的是，我的虚拟机设置了 *网卡桥接* ，这使得虚拟机能够与我的本机 **处于同一网段** 下：\n\n- 本机ip：192.168.123.100\n- 虚拟机ip：192.168.123.108\n\n以下为登陆过程：\n\n```bash\n➜  ~ ssh jabin@192.168.123.108\nThe authenticity of host '192.168.123.108 (192.168.123.108)' can't be established.\nECDSA key fingerprint is SHA256:03HGcFD36maxOk1mMh8G2HYJ6wvWSTTEm9aJZf0ovig.\nAre you sure you want to continue connecting (yes/no/[fingerprint])? yes\nWarning: Permanently added '192.168.123.108' (ECDSA) to the list of known hosts.\njabin@192.168.123.108's password:\nWelcome to Ubuntu 14.04 LTS (GNU/Linux 3.13.0-24-generic x86_64)\n\n * Documentation:  https://help.ubuntu.com/\n\n  System information as of Mon Dec 28 21:07:16 CST 2020\n\n  System load:  0.06              Processes:           165\n  Usage of /:   2.2% of 60.90GB   Users logged in:     0\n  Memory usage: 4%                IP address for eth0: 192.168.123.108\n  Swap usage:   0%\n\n  Graph this data and manage this system at:\n    https://landscape.canonical.com/\n\nNew release '16.04.7 LTS' available.\nRun 'do-release-upgrade' to upgrade to it.\n\nLast login: Mon Dec 28 21:07:16 2020\njabin@ubuntu-linux14:~$\n```\n\n### 2.3. 查看系统中所有的守护进程\n\n通过系统的 *Terminal* 执行命令 `ps -axj`，其中 `-axj` 是程序 `ps` 的参数，等同于`-a -x -j`，三个参数分别代表：\n\n- -a：显示由其他用户所拥有的进程的状态。\n- -x：显示没有控制终端的进程状态。\n- -j：显示与作业相关的信息：会话ID、进程组ID、控制终端以及终端进程组ID。\n\n运行结果如下（只保留了前三行，其余省略）：\n\n```bash\nPPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND\n    0     1     1     1 ?           -1 Ss       0   0:00 /sbin/init\n    0     2     0     0 ?           -1 S        0   0:00 [kthreadd]\n    2     3     0     0 ?           -1 S        0   0:00 [ksoftirqd/0]\n    2     4     0     0 ?           -1 S        0   0:00 [kworker/0:0]\n    2     5     0     0 ?           -1 S<       0   0:00 [kworker/0:0H]\n    2     7     0     0 ?           -1 S        0   0:00 [rcu_sched]\n...\n```\n\n标题的意义如下：\n\n- *PPID* ：*父进程ID*\n- *PID* ：*进程ID*\n- *PGID* ：*进程组ID*\n- *SID* ：*会话ID*\n- *TTY* ：*终端名称*\n- *TPGID* ：*终端进程组ID*\n- *UID* ：*用户ID*\n- *TIME* ：*累积CPU运行时间*\n- *COMMAND* ：*命令字符串*\n\n这里可以看到，结果中的第一行就是 *init* 进程，同时也是 **1号进程**。最下面四行中的进程的父进程都是 **2号进程** ，而 **2号进程** 的父进程又是 **0号进程** ，这些进程都属于 **内核级别的进程** ，暂时不过多关注它们的内容。\n\n### 2.3. 找到Nginx和SSH的守护进程\n\n安装 *nginx* 和 *openssh-server* 的意义在于，我们都知道（不知道的现在就知道了）这两个软件都会在系统中运行各自的 *守护进程* 在后台不断运行提供服务，不同是前者是 **等待http请求** ，后者是等待 **ssh连接**。\n\n通过 **2.2** 已经可以找出所有的守护进程了，通过 *grep* 就可以很方便地提取出特定的结果行了。\n\n```bash\njabin@ubuntu-linux14:~$ ps -axj | grep -E \"nginx|ssh\"\n    1  1275  1275  1275 ?           -1 Ss       0   0:00 nginx: master process /usr/sbin/nginx\n 1275  1276  1275  1275 ?           -1 S       33   0:00 nginx: worker process\n 1275  1277  1275  1275 ?           -1 S       33   0:01 nginx: worker process\n 1275  1278  1275  1275 ?           -1 S       33   0:01 nginx: worker process\n 1275  1279  1275  1275 ?           -1 S       33   0:01 nginx: worker process\n    1  2323  2323  2323 ?           -1 Ss       0   0:00 /usr/sbin/sshd -D\n 2323  2359  2359  2359 ?           -1 Ss       0   0:00 sshd: jabin [priv]  \n 2359  2430  2359  2359 ?           -1 S     1000   0:00 sshd: jabin@pts/0   \n 2431  2451  2450  2431 pts/0     2450 S+    1000   0:00 grep --color=auto -E nginx|ssh\njabin@ubuntu-linux14:~$\n```\n\n除去最后一行不看（显然这一行只是我们当前输入命令相关的进程），其余的结果中有 **5** 个进程是 *nginx* 的守护进程，并且通过 *PID* 和 *PPID* 可以看出，这 **5** 个进程中第 **1** 个是 *主进程* ，其余都它的 *子进程*：\n\n```bash\nPPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND\n1  1275  1275  1275 ?           -1 Ss       0   0:00 nginx: master process /usr/sbin/nginx\n1275  1276  1275  1275 ?           -1 S       33   0:00 nginx: worker process\n1275  1277  1275  1275 ?           -1 S       33   0:01 nginx: worker process\n1275  1278  1275  1275 ?           -1 S       33   0:01 nginx: worker process\n1275  1279  1275  1275 ?           -1 S       33   0:01 nginx: worker process\n```\n\n有关 *ssh* 的守护进程有 **3** 个，同样通过 *PID* 和 *PPID* 可以看出只有第 **1** 个是 *主进程*：\n\n```bash\nPPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND\n1  2323  2323  2323 ?           -1 Ss       0   0:00 /usr/sbin/sshd -D\n2323  2359  2359  2359 ?           -1 Ss       0   0:00 sshd: jabin [priv]  \n2359  2430  2359  2359 ?           -1 S     1000   0:00 sshd: jabin@pts/0  \n```\n\n可以额外注意的一点是， *ssh* 有关结果第三行中的 `jabin@pts/0` 其实指示了这个 *子进程* 其实就服务于 **我的主机开启的这次ssh连接**，通过`who am i`指令就可以验证这一点（留意结果中的 `pts/0` ）：\n\n```bash\njabin@ubuntu-linux14:~$ who am i\njabin    pts/0        2020-12-29 00:10 (macbook-pro-2.lan)\njabin@ubuntu-linux14:~$\n```\n\n### 2.4. 守护进程的特点\n\n观察 *nginx* 和 *sshd* 的 *主进程* 的 **进程信息** ：\n\n```bash\n1  1275  1275  1275 ?           -1 Ss       0   0:00 nginx: master process /usr/sbin/nginx\n1  2323  2323  2323 ?           -1 Ss       0   0:00 /usr/sbin/sshd -D\n```\n\n可以发现一些共同点：\n\n- *PPID* 都为 `1`。\n- *TTY* 都为 `?`。\n- *TPGID* 都为 `-1`。\n- *SID* 都等于 *PID*。\n- *PGID* 都等于 *PID*。\n\n这说明：\n\n- 他们的 *父进程* 都是 **1号进程** 。\n- 他们都没有 *控制终端* 。\n- 他们都没有 *控制终端* 所以都为 **-1** 。\n- 该进程的 *会话ID* 等于该进程的 *进程ID* ，即该进程是 *会话首进程（session leader）* 。\n- 该进程的 *进程组ID* 等于该进程的 *进程ID* ，即该进程是 *进程组组长* 。\n\n## 1.4 什么是Linux的process group\n\n## 1.5 什么是working directory\n\n## 1.6 什么是masks\n\n\n\n## 3. 如何启动一个守护进程\n\n\n\n## 4. 守护进程等于后台进程吗\n\n结论：守护进程不等于后台进程。\n\n**后台进程** 是指工作在后台的进程。而守护进程毫无疑问会工作在后台，所以它一定是一个后台进程。\n\n但反过来说后台进程一定是守护进程却是错误的，因为后台工作只是守护进程 **其中之一** 的特性。\n\n## 5. 参考文章\n\n- *Unix环境高级编程：第9章*\n- *Unix环境高级编程：第13章*\n- [*Daemon 起源：中文翻译*](https://linuxtoy.org/archives/the-origin-of-the-word-daemon.html)\n- [*Daemon 起源：原文*](http://ei.cs.vt.edu/~history/Daemon.html)\n- [*Daemon Definition*](http://www.linfo.org/daemon.html)\n- [*WiKi：Daemon (computing)*](https://en.wikipedia.org/wiki/Daemon_(computing))\n- [*后台进程不等于守护进程*](https://www.cnblogs.com/SophiaTang/archive/2011/11/25/2263654.html)\n- [*what is pts/0 and (:0.0) in linux when typing who am i*](https://unix.stackexchange.com/questions/72177/what-is-pts-0-and-0-0-in-linux-when-typing-who-am-i)\n- [*linux 的nohup & 和daemon 总结*](https://blog.csdn.net/lovemdx/article/details/20529563)\n- [*linux中创建守护进程是为什么要改变工作目录*](https://zhidao.baidu.com/question/429901771.html)\n","excerpt":"本文要求你对进程有一定概念。如果不懂什么是进程，推荐你查看我的文章 操作系统系列之——程序 和 操作系统系列之——进程 。 1. 概念解释 守护进程 （ Daemon Process ），是一种  不被用户直接控制的  、  运行在后台  的进程。通常而言守护进程的进程名称会以  字母d…"},{"slug":"posts/draft/draft","title":"草稿","content":"---\ntitle: \"草稿\"\ndate: 2021-01-15T21:24:06+08:00\ntags: []\ncategories: [\"draft\"]\ndraft: true\n---\n\n## 1. PCB\n\n进程的另一个名字是 **任务（task）** 。 Linux 内核通常把进程也叫做任务。\n\n前文也提到过PCB，这是进程在操作系统中的数据结构，而众所周知 Linux 是用 C 语言编写的开源操作系统，因此我们可以看看 Linux 的源码中是如何定义PCB的。\n\n在 Linux 源码中PCB被定义为 **task_struct**， 由于其完整定义有 **700+** 行，便于浏览这里只摘出了部分比较常用的属性：\n\n```c\nstruct task_struct {\n    pid_t               pid;\n    pid_t               tgid;\n\n    /* -1 unrunnable, 0 runnable, >0 stopped: */\n    volatile long           state;\n\n    unsigned int            policy;\n\n    int         prio;\n\n    int             exit_state;\n    int             exit_code;\n    int             exit_signal;\n    /* The signal sent when the parent dies: */\n    int             pdeath_signal;\n\n    unsigned            in_execve:1;\n    unsigned            in_iowait:1;\n\n    /* Real parent process: */\n    struct task_struct __rcu    *real_parent;\n\n    /* Recipient of SIGCHLD, wait4() reports: */\n    struct task_struct __rcu    *parent;\n\n    /*\n     * Children/sibling form the list of natural children:\n     */\n    struct list_head        children;\n    struct list_head        sibling;\n    struct task_struct      *group_leader;\n\n    struct list_head        tasks;\n};\n```\n\n## 2. 父进程与子进程\n\n### 2.1 进程家族树\n\n说到父进程与子进程 ，就不得不提到Unix的 **进程家族树** 。\n\nUnix 的进程之间存在一个明显的继承关系，所有的进程都是 PID 为1的 init 进程的后代（排除一些内核进程，他们是 0号进程的后代）。内核在系统启动的最后阶段启动 init 进程，该进程读取系统的初始化脚本（initscript）并执行其他的相关程序，最终完成系统启动的整个过程。\n\n系统中的每个进程必有一个父进程，相应的每个进程也可以拥有零个或多个子进程。拥有同一个父进程的所有进程被成为兄弟。进程间的关系存放在 task_struct 中。每个 task_struct 包含一个指向其父进程 task_struct 的指针，叫做 **parent** 指针，还包含了一个称为 **children** 的子进程链表。\n\n### 2.2 进程的创建\n\n许多其他的操作系统都提供 **产生（spawn）** 进程的机制，即在新的地址空间创建进程，读入可执行文件，最后开始执行。\n\n但 Unix 的进程创建很特别，它将上述步骤分解到两个单独的函数 **fork()** 和 **exec()** 中去执行。\n\n#### 2.2.1 fork()\n\n首先，fork() 通过 **拷贝** 当前进程创建一个子进程，此时该子进程与父进程的区别仅仅在于 PID（每个进程具有唯一的 PID ） 、PPID（子进程的 PPID 将是被拷贝进程的 PID ）和某些资源和统计量（例如，挂起的信号，它没有必要被继承）。\n\nfork() 被调用一次，但会在父进程和新产生的子进程中各返回一次（共返回两次）。两次返回的区别是子进程得到的返回值是0，而父进程得到的返回值是新的子进程的 PID 。\n\nfork() 让父进程得到子进程的 PID 的原因是：一个进程的子进程可以有多个，并且除了 fork() 的返回值外，没有任何一个函数能够得到该子进程的 PID 了。\n\nfork() 让子进程得到返回值0的原因是：一个进程有且只有一个父进程，所以子进程可以通过 getppid() 来得到父进程的 PID ，并且返回值是否为0可以判断当前进程是否是新创建的子进程（尽管在系统中的的确确存在 PID 为0的进程，但0号进程是内核进程，并且是整个系统中的第一个进程，所以不可能是一个子进程的 PID）。\n\n##### 2.2.1.1 fork() 示例\n\n这是一个非常简单的 fork() 示例，运行这个示例你将会明白返回两次是什么意思。\n\n```c\ninclude<stdio.h>\n#include <unistd.h>\n\nint main(){\n    int pid = fork();\n    printf(\"pid = %d\\n\", pid);\n}\n```\n\n#### 2.2.2 exec()\n\nexec() 函数负责读取可执行文件，并将其载入地址空间开始运行。exec() 指所有 exec() 一族的函数，包括 execve() 、 execlp()、 execle() 、 execv() 、 execvp() 等。\n\n进程执行 exec() 程序时，该进程执行的程序完全替换为新程序，且新程序从 main 函数（回想 C 语言的 main 函数）开始执行。因为 exec() 只是用全新的程序替换了当前进程的正文、数据、堆和栈段，因此 exec() 并不会产生新的进程，更并不会改变当前进程的 PID。\n\n#### 2.2.3 组合使用 fork() 和 exec()\n\n在 Unix 中创建一个新进程的方式是先使用 fork() ，通过 fork() 的返回值判断出哪个是子进程，并在子进程中执行 exec() 。下面是一个简单的 C 语言代码示例：\n\n```c\n\n```\n\n## 进程组\n\n## 会话组\n\n## Nginx 配置\n\n```Nginx\n##\n# You should look at the following URL's in order to grasp a solid understanding\n# of Nginx configuration files in order to fully unleash the power of Nginx.\n# https://www.nginx.com/resources/wiki/start/\n# https://www.nginx.com/resources/wiki/start/topics/tutorials/config_pitfalls/\n# https://wiki.debian.org/Nginx/DirectoryStructure\n#\n# In most cases, administrators will remove this file from sites-enabled/ and\n# leave it as reference inside of sites-available where it will continue to be\n# updated by the nginx packaging team.\n#\n# This file will automatically load configuration files provided by other\n# applications, such as Drupal or Wordpress. These applications will be made\n# available underneath a path with that package name, such as /drupal8.\n#\n# Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples.\n##\n\n# Default server configuration\n#\nserver {\n\tlisten 80 default_server;\n\tlisten [::]:80 default_server;\n\n\t# SSL configuration\n\t#\n\t# listen 443 ssl default_server;\n\t# listen [::]:443 ssl default_server;\n\t#\n\t# Note: You should disable gzip for SSL traffic.\n\t# See: https://bugs.debian.org/773332\n\t#\n\t# Read up on ssl_ciphers to ensure a secure configuration.\n\t# See: https://bugs.debian.org/765782\n\t#\n\t# Self signed certs generated by the ssl-cert package\n\t# Don't use them in a production server!\n\t#\n\t# include snippets/snakeoil.conf;\n\n\t#root /var/www/html;\n\n\t# Add index.php to the list if you are using PHP\n\t#index index.html index.htm index.nginx-debian.html;\n\n\tserver_name _;\n\n\tlocation / {\n\t\t# First attempt to serve request as file, then\n\t\t# as directory, then fall back to displaying a 404.\n\t\ttry_files $uri $uri/ =404;\n\t}\n\tlocation /mike/ {\n\t\talias /home/mike/nginx-folder/;\n\t}\n\t# pass PHP scripts to FastCGI server\n\t#\n\t#location ~ \\.php$ {\n\t#\tinclude snippets/fastcgi-php.conf;\n\t#\n\t#\t# With php-fpm (or other unix sockets):\n\t#\tfastcgi_pass unix:/var/run/php/php7.0-fpm.sock;\n\t#\t# With php-cgi (or other tcp sockets):\n\t#\tfastcgi_pass 127.0.0.1:9000;\n\t#}\n\n\t# deny access to .htaccess files, if Apache's document root\n\t# concurs with nginx's one\n\t#\n\t#location ~ /\\.ht {\n\t#\tdeny all;\n\t#}\n}\n\n\n# Virtual Host configuration for example.com\n#\n# You can move that to a different file under sites-available/ and symlink that\n# to sites-enabled/ to enable it.\n#\n\nserver {\n\n\t# SSL configuration\n\t\n\t#listen 443 ssl default_server;\n\t#listen [::]:443 ssl default_server;\n\t\n\t# Note: You should disable gzip for SSL traffic.\n\t# See: https://bugs.debian.org/773332\n\t#\n\t# Read up on ssl_ciphers to ensure a secure configuration.\n\t# See: https://bugs.debian.org/765782\n\t#\n\t# Self signed certs generated by the ssl-cert package\n\t# Don't use them in a production server!\n\t#\n\t# include snippets/snakeoil.conf;\n\n\t#root /var/www/html;\n\n\t# Add index.php to the list if you are using PHP\n\t#index index.html index.htm index.nginx-debian.html;\n\tserver_name hk1.jabni.top; # managed by Certbot\n\n\n        location / {\n        \tproxy_http_version 1.1;\n                proxy_set_header Host $host;\n                proxy_set_header X-Real-IP $remote_addr;\n                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n               proxy_pass http://127.0.0.1:3000;\n        }\n\t# pass PHP scripts to FastCGI server\n\t#\n\t#location ~ \\.php$ {\n\t#\tinclude snippets/fastcgi-php.conf;\n\t#\n\t#\t# With php-fpm (or other unix sockets):\n\t#\tfastcgi_pass unix:/var/run/php/php7.0-fpm.sock;\n\t#\t# With php-cgi (or other tcp sockets):\n\t#\tfastcgi_pass 127.0.0.1:9000;\n\t#}\n\n\t# deny access to .htaccess files, if Apache's document root\n\t# concurs with nginx's one\n\t#\n\t#location ~ /\\.ht {\n\t#\tdeny all;\n\t#}\n\n\n    listen [::]:443 ssl ipv6only=on; # managed by Certbot\n    listen 443 ssl; # managed by Certbot\n    ssl_certificate /etc/letsencrypt/live/hk1.jabni.top/fullchain.pem; # managed by Certbot\n    ssl_certificate_key /etc/letsencrypt/live/hk1.jabni.top/privkey.pem; # managed by Certbot\n    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot\n    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot\n\n}\n# server {\n#     if ($host = hk1.jabni.top) {\n#         return 301 https://$host$request_uri;\n#     } # managed by Certbot\n# \n# \n# \tlisten 80 ;\n# \tlisten [::]:80 ;\n#     server_name hk1.jabni.top;\n#     return 404; # managed by Certbot\n# \n# \n# }\n\n```\n\n## docker \n\n- /home/docker-data/murmur:/data 本机的 /home/docker-data/murmur 映射为 /data\n\n```bash\n$ docker pull coppit/mumble-server\n$ docker run --name=mumble-server -d --net=host -v /home/docker-data/murmur:/data -t coppit/mumble-server\n```\n\n## docker -1 \n\n```bash\n$ docker pull phlak/mumble\n$ docker run -d -p 64738:64738 -p 64738:64738/udp -v mumble-data:/etc/mumble --name mumble-server phlak/mumble\n```\n- [docker-mumble] (https://github.com/PHLAK/docker-mumble)\n\n数据将被放在 /var/lib/docker/volumes/mumble-data/_data\n可以通过这个命令看到\n\ndocker inspect mumble-server | less\n\n\ndocker run -d -p 64739:64738 -p 64739:64738/udp -v /home/docker-data/murmur:/etc/mumble --name mumble-server-1 phlak/mumble\n\n\n- [docker容器中无权限操作挂载宿主机的目录解决方案](https://zhuanlan.zhihu.com/p/43105630)\n\n\"Propagation\":\"rprivate\" } ], 从里面可以出这是一个 bind mount,并且是只读挂载。\n- [Docker 持久存储介绍(十三)](https://blog.csdn.net/wangzan18/article/details/85219442)\n\n```\n$ docker pull mysql:latest\n$ docker images\n```\n\n172.17.0.1\ndocker run -d --name kafka -p 9092:9092 -e KAFKA_BROKER_ID=0 -e KAFKA_ZOOKEEPER_CONNECT=docker.for.mac.host.internal:2181/kafka -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://docker.for.mac.host.internal:9092 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 wurstmeister/kafka\n\ndocker run -d --name kafka -p 9092:9092 -e KAFKA_BROKER_ID=0 -e KAFKA_ZOOKEEPER_CONNECT=172.17.0.1:2181/kafka -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://172.17.0.1:9092 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 wurstmeister/kafka\n\nkafka 启动不了 内存不够\n```\n\nExcluding KAFKA_HOME from broker config\n[Configuring] 'port' in '/opt/kafka/config/server.properties'\n[Configuring] 'advertised.listeners' in '/opt/kafka/config/server.properties'\n[Configuring] 'broker.id' in '/opt/kafka/config/server.properties'\nExcluding KAFKA_VERSION from broker config\n[Configuring] 'listeners' in '/opt/kafka/config/server.properties'\n[Configuring] 'zookeeper.connect' in '/opt/kafka/config/server.properties'\n[Configuring] 'log.dirs' in '/opt/kafka/config/server.properties'\n#\n# There is insufficient memory for the Java Runtime Environment to continue.\n# Native memory allocation (mmap) failed to map 1073741824 bytes for committing reserved memory.\nOpenJDK 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000c0000000, 1073741824, 0) failed; error='Out of memory' (errno=12)\n# An error report file with more information is saved as:\n# //hs_err_pid1.log\n\n```\n\n## nat 协议\n\nNAT转换是怎么工作的？ - 网易云信的回答 - 知乎\nhttps://www.zhihu.com/question/31332694/answer/470426521\n\n## docker gitea\n\ndocker run -d -p 3000:3000  -p 3322:22 -v gitea-data:/data/gitea --name gitea gitea/gitea   \n\n\nhttps://stackoverflow.com/questions/64416940/docker-every-command-results-in-a-fatal-error-runtime-out-of-memory\n\nhttps://www.cnblogs.com/atuotuo/p/13549012.html\n\nhttps://blog.csdn.net/u010117864/article/details/104952104\n\n```\nroot@aligz01:~# free -m\n              total        used        free      shared  buff/cache   available\nMem:            923         761          63           5          99          41\nSwap:             0           0           0\nroot@aligz01:~#\n```\n\n```\nroot@aligz01:~# cd /usr/\nroot@aligz01:/usr# mkdir swap\n```\n\n```\nroot@aligz01:/usr/swap# dd if=/dev/zero of=swapfile bs=1M count=2048\n2048+0 records in\n2048+0 records out\n2147483648 bytes (2.1 GB, 2.0 GiB) copied, 30.4012 s, 70.6 MB/s\nroot@aligz01:/usr/swap# mkswap swapfile\nmkswap: swapfile: insecure permissions 0644, 0600 suggested.\nSetting up swapspace version 1, size = 2 GiB (2147479552 bytes)\nno label, UUID=08dbc4e3-24b5-4377-a7f0-0b8fc088d93a\nroot@aligz01:/usr/swap# swapon swapfile\nswapon: /usr/swap/swapfile: insecure permissions 0644, 0600 suggested.\n\n$ \"/usr/swap/swapfile swap swap defaults 0 0\" >> /etc/fstab\n```\n\n\n\n其中，if表示input_file输入文件，of表示output_file输出文件，bs表示block_size块大小，count表示计数。这里，我采用了数据块大小为1M，数据块数目为2048，这样分配的空间就是2G大小。\n\nhttp://www.lining0806.com/linux%E4%B8%8B%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/\n\n## tty\n\n强推 [The TTY demystified](http://www.linusakesson.net/programming/tty/index.php)\n\n- what is tty\n- what is control terminal\n- what is terminal\n- what is shell\n- what is /dev/tty\n- what is stdin and stdout\n- \n\n在 Unix 中 ，`tty` 是一个命令，用来输出终端连接标准输入的文件名。\n\ntty 是 TeleTYpewriter 的缩写，TeleTYpewriter 的中文意思是电传打字电报机，这是一种用来发送键盘输入信息到远端的设备，它在 20 世纪中叶被广泛使用。电传打字电报机有一个用于输入的键盘、一个用来查看自己输入内容的本地的打印机、一个发射器，消息可以通过电线或无线电发送，\n\ntty 命令通常用来检测当前的输出媒介是否为一个终端，若当前输出媒介为终端，该命令会输出当前终端标准输入的文件名，若不存在该标准输入文件，则说明当前输出媒介并非是一个终端（例如使用管道组合了命令的情况 `echo | tty | cat` ），执行 tty 命令将输出一个 “not a tty” 到标准输出并且以状态 1 退出来表示输出媒介并非终端。\n\n- http://www.linusakesson.net/programming/tty/index.php\n- https://en.wikipedia.org/wiki/Tty_(unix)\n- https://linux.die.net/man/4/tty\n- https://simple.wikipedia.org/wiki/Teletypewriter\n- https://stackoverflow.com/questions/8514735/what-is-special-about-dev-tty\n\n\nubuntu 18.04 添加 sudo 权限\n\nubuntu里面没有wheel组，取而代之的是sudo，添加到sudo组即可\n\n```bash\nusermod -a -G sudo jabin\n```\n\nsudo docker run -d -p 64738:64738 -p 64738:64738/udp \\\n    -v /opt/docker/mnt/murmur/data:/data \\\n    -v /opt/docker/mnt/murmur/config/murmur.ini:/etc/murmur.ini \\\n    --name=murmur \\\n    mattikus/murmur\n\n\ndocker run --name mysql5_6 \\\n-v /opt/docker/mnt/mysql5_6/conf.d:/etc/mysql/conf.d \\\n-v /opt/docker/mnt/mysql5_6/data:/var/lib/mysql \\\n-p 3306:3306 \\\n-e MYSQL_ROOT_PASSWORD=abc123 \\\n-d mysql:5.6.50\n\nsudo docker pull redis:latest\n\nsudo docker run -itd \\\n--name redis \\\n-p 6379:6379 \\\n-v /opt/docker/mnt/redis/data:/data \\\nredis\n\nsudo docker run -itd \\\n--name mongo \\\n-v /opt/docker/mnt/mongo/data:/data \\\n-p 27017:27017 \\\n-e MONGO_INITDB_ROOT_USERNAME=root \\\n-e MONGO_INITDB_ROOT_PASSWORD=abc123 \\\nmongo \\\n--auth\n\ncreate database code_sharing charset utf8mb4 collate utf8mb4_unicode_ci","excerpt":"1. PCB 进程的另一个名字是  任务（task）  。 Linux 内核通常把进程也叫做任务。 前文也提到过PCB，这是进程在操作系统中的数据结构，而众所周知 Linux 是用 C 语言编写的开源操作系统，因此我们可以看看 Linux 的源码中是如何定义PCB的。 在 Linux 源码中PCB被定义为  task…"},{"slug":"posts/draft/github-actions","title":"Github Actions","content":"---\ntitle: \"Github Actions\"\ndate: 2020-12-13T22:35:46+08:00\ncategories: []\ntags: []\ndraft: true\n---\n\n[https://docs.github.com/en/free-pro-team@latest/actions/reference/context-and-expression-syntax-for-github-actions#contexts](https://docs.github.com/en/free-pro-team@latest/actions/reference/context-and-expression-syntax-for-github-actions#contexts)\n","excerpt":"https://docs.github.com/en/free-pro-team@latest/actions/reference/context-and-expression-syntax-for-github-actions#contexts"},{"slug":"posts/draft/https","title":"Https","content":"---\ntitle: \"Https\"\ndate: 2021-02-16T15:29:40+08:00\ndraft: true\n---\n\n## openssl\n\n开源的命令行工具，可以用来生成 keys ， 证书 ， CSR \n\n## 步骤\n\nhttps://www.cnblogs.com/qiyueqi/p/11551238.html\n\n1. 生成 CA 私钥\n\n    ```bash\n    jabin@dev-ubuntu [01:59:05] [~/ssl]\n    -> % openssl genrsa -out local.key 2048\n    Generating RSA private key, 2048 bit long modulus (2 primes)\n    ...................+++++\n    ..................+++++\n    e is 65537 (0x010001)\n    ```\n\n2. 生成 CA 证书请求\n\n    ```bash\n    jabin@dev-ubuntu [01:59:25] [~/ssl]\n    -> % openssl req -new -key local.key -out local.csr\n    Can't load /home/jabin/.rnd into RNG\n    140594689962432:error:2406F079:random number generator:RAND_load_file:Cannot open file:../crypto/rand/randfile.c:88:Filename=/home/jabin/.rnd\n    You are about to be asked to enter information that will be incorporated\n    into your certificate request.\n    What you are about to enter is what is called a Distinguished Name or a DN.\n    There are quite a few fields but you can leave some blank\n    For some fields there will be a default value,\n    If you enter '.', the field will be left blank.\n    -----\n    Country Name (2 letter code) [AU]:CN\n    State or Province Name (full name) [Some-State]:GD\n    Locality Name (eg, city) []:SZ\n    Organization Name (eg, company) [Internet Widgits Pty Ltd]:\n    Organizational Unit Name (eg, section) []:dev\n    Common Name (e.g. server FQDN or YOUR name) []:ubuntu\n    Email Address []:dev@dev.com\n\n    Please enter the following 'extra' attributes\n    to be sent with your certificate request\n    A challenge password []:abc123\n    An optional company name []:dev\n    ```\n\n3. 生成 CA 根证书\n\n    ```bash\n    jabin@dev-ubuntu [02:02:46] [~/ssl]\n    -> % openssl x509 -req -in local.csr -extensions v3_ca -signkey local.key -out local.crt\n    Signature ok\n    subject=C = CN, ST = GD, L = SZ, O = Internet Widgits Pty Ltd, OU = dev, CN = ubuntu, emailAddress = dev@dev.com\n    Getting Private key\n    ```\n\n4. 生成server私匙\n\n    ```bash\n    jabin@dev-ubuntu [02:04:04] [~/ssl]\n    -> % openssl genrsa -out my_server.key 2048\n    Generating RSA private key, 2048 bit long modulus (2 primes)\n    .....................................................................+++++\n    .........+++++\n    e is 65537 (0x010001)\n    ```\n\n5. 生成server证书请求\n\n    ```bash\n    jabin@dev-ubuntu [02:04:18] [~/ssl]\n    -> % openssl x509 -req -in local.csr -extensions v3_ca -signkey local.key -out local.crt\n    Signature ok\n    subject=C = CN, ST = GD, L = SZ, O = Internet Widgits Pty Ltd, OU = dev, CN = ubuntu, emailAddress = dev@dev.com\n    Getting Private key\n    jabin@dev-ubuntu [02:06:01] [~/ssl]\n    -> % openssl req -new -key my_server.key -out my_server.csr\n    Can't load /home/jabin/.rnd into RNG\n    139691214037440:error:2406F079:random number generator:RAND_load_file:Cannot open file:../crypto/rand/randfile.c:88:Filename=/home/jabin/.rnd\n    You are about to be asked to enter information that will be incorporated\n    into your certificate request.\n    What you are about to enter is what is called a Distinguished Name or a DN.\n    There are quite a few fields but you can leave some blank\n    For some fields there will be a default value,\n    If you enter '.', the field will be left blank.\n    -----\n    Country Name (2 letter code) [AU]:CN\n    State or Province Name (full name) [Some-State]:GD\n    Locality Name (eg, city) []:SZ\n    Organization Name (eg, company) [Internet Widgits Pty Ltd]:dev\n    Organizational Unit Name (eg, section) []:dev\n    Common Name (e.g. server FQDN or YOUR name) []:ubuntu\n    Email Address []:dev@dev.com\n\n    Please enter the following 'extra' attributes\n    to be sent with your certificate request\n    A challenge password []:abc123\n    An optional company name []:dev\n    ```\n\n6. 生成server证书\n\n    ```bash\n    jabin@dev-ubuntu [02:06:49] [~/ssl]\n    -> %  openssl x509 -days 365 -req -in my_server.csr -extensions v3_req -CAkey local.key -CA local.crt -CAcreateserial -out my_server.crt\n    Signature ok\n    subject=C = CN, ST = GD, L = SZ, O = dev, OU = dev, CN = ubuntu, emailAddress = dev@dev.com\n    Getting CA Private Key\n    ```\n\n## Certbot\n\nhttps://www.jianshu.com/p/1eb7060c5ede\n\ncertbot certonly --preferred-challenges dns --manual  -d \"*.bysir.cn\" --server https://acme-v02.api.letsencrypt.org/directory\n\n# nginx 配置\n\n省略","excerpt":"openssl 开源的命令行工具，可以用来生成 keys ， 证书 ， CSR  步骤 https://www.cnblogs.com/qiyueqi/p/11551238.html 生成 CA 私钥 生成 CA 证书请求 生成 CA 根证书 生成server私匙 生成server证书请求 生成server…"},{"slug":"posts/draft/linux-service","title":"有关Linux中的Service","content":"---\ntitle: \"有关Linux中的Service\"\ndate: 2020-12-22T15:18:25+08:00\ndraft: true\n---\n\n> 本文不会涉及很多专业的表达，因为我并不喜欢那些晦涩难懂的定义，并且事实上我也记不住那些定义。。。\n\n## 1. 我说的Service是什么\n\n> 我假设你已经接触过Apache、Nginx这类HTTP服务器，又或者是MySQL、MongoDB、Redis这类数据库。\n\n无论是**HTTP服务器**又或者是**数据库**都有一个共同的特点，就是**默默地运行**在**后台**等待你的请求并给予你响应，我称这样的程序为**Service(服务)**。\n\n## 2. 前台与后台\n\n> 以下提到的命令需要在linux环境执行。\n\n### 2.1. 前台\n\n当你运行一个前台程序`ping`时:\n\n```cmd\nroot@jabingp /etc                                                                     [16:52:07] \n> # ping google.com                                                                                             \nPING google.com (216.58.200.46) 56(84) bytes of data.\n```\n\n你会惊奇的发现你得不到任何的回应，因为在国内你的网络环境确确实实访问不到`google`。\n\n这时候你感到非常生气，你想直接关掉这个该死的程序，于是你按下了`Ctrl`+`C`_（这里通过组合键发出了一个关闭信号，ping接收到这个信号后就关闭了）_，这该死的程序终于**停止了**。\n\n```cmd\nroot@jabingp /etc                                                                     [16:57:18] \n> # ping google.com                                                                                             \nPING google.com (93.46.8.90) 56(84) bytes of data.\n^C\n--- google.com ping statistics ---\n19 packets transmitted, 0 received, 100% packet loss, time 17999ms\n```\n\n### 2.2. 后台\n\n但当你想关闭运行在后台的服务时，就不是按个组合键那么简单了。假如我们把上面的`ping`命令放到后台来执行，在`linux`的命令行里你只需要加上`&`就可以，这里我们来ping一个有回应的网站，同时我们指定一下ping的**间隔为10秒**一次，不要让它刷屏了。\n\n先来不后台运行：\n\n```cmd\nroot@jabingp /tmp                                                                     [17:25:59] \n> # ping baidu.com -i 10                                                                                        \nPING baidu.com (39.156.69.79) 56(84) bytes of data.\n64 bytes from 39.156.69.79 (39.156.69.79): icmp_seq=1 ttl=49 time=40.0 ms\n64 bytes from 39.156.69.79 (39.156.69.79): icmp_seq=2 ttl=49 time=39.9 ms\n64 bytes from 39.156.69.79 (39.156.69.79): icmp_seq=3 ttl=49 time=39.9 ms\n```\n\n现在加上`&`后台运行：\n\n```cmd\nroot@izwz98zwp24pi5mjf0bo9az /tmp                                                                     [17:30:27] \n> # ping baidu.com -i 10 &                                                                                      \n[1] 28786\nPING baidu.com (39.156.69.79) 56(84) bytes of data.                                                              \n\nroot@izwz98zwp24pi5mjf0bo9az /tmp                                                                     [17:30:29] \n> # 64 bytes from 39.156.69.79 (39.156.69.79): icmp_seq=1 ttl=49 time=40.0 ms                                   \n64 bytes from 39.156.69.79 (39.156.69.79): icmp_seq=2 ttl=49 time=40.0 ms\n64 bytes from 39.156.69.79 (39.156.69.79): icmp_seq=3 ttl=49 time=39.9 ms\n64 bytes from 39.156.69.79 (39.156.69.79): icmp_seq=4 ttl=49 time=40.0 ms\n64 bytes from 39.156.69.79 (39.156.69.79): icmp_seq=5 ttl=49 time=40.0 ms\n64 bytes from 39.156.69.79 (39.156.69.79): icmp_seq=6 ttl=49 time=39.9 ms\n64 bytes from 39.156.69.79 (39.156.69.79): icmp_seq=7 ttl=49 time=40.0 ms\n64 bytes from 39.156.69.79 (39.156.69.79): icmp_seq=8 ttl=49 time=40.0 ms\n64 bytes from 39.156.69.79 (39.156.69.79): icmp_seq=9 ttl=49 time=39.9 ms\n```\n\n你会发现无论你怎么`Ctrl`+`C`都无法关闭ping这个程序了，因为它已经在后台运行了。并且还会将ping的结果不断的输出到控制台上，让你的控制台看起来很错乱。\n\n你现在十分不爽，你想赶紧把这个扰乱你视线的ping关闭，但是组合键已经失效了，你无能为力。\n\n虽然现在不能直接通过组合键发出信号让ping关闭，但是借助操作系统内置的进程管理我们还是可以找到这个烦人的东西并关掉的，执行命令`ps -aux | grep ping`：\n\n```cmd\nps -aux | grep ping\nroot     28786  0.0  0.1 147820  1996 pts/0    SN   17:30   0:00 ping baidu.com -i 10\n```\n\n可以在第二行的结果中看到了我们刚刚敲过的`ping baidu.com -i 10`命令，并且留意`28786`这个数字，这个是`进程id`，也就是这个进程的**身份证**，有了这个我们就可以把这个烦人的东西关掉了。不用理会控制台上的输出，只需要输入或者复制`kill -9 28786`并且回车\n\n```cmd\nkill -9 28786\n[1]  + 28786 killed     ping baidu.com -i 10   \n```\n\n你会发现这个烦人的东西已经被关掉了。\n\n### 2.3 总结\n\n通过前面两个例子可以看到，当程序在前台运行的时候，我们使用组合键`Ctrl`+`C`就可以发出关闭信号使得程序关闭。但是当程序到了后台运行时，我们想要关闭这个进程就需要借助操作系统的`ps`命令先获取这个**进程**的`id`，再通过`kill`命令去向这个`id`的进程发出关闭信号才能得它关闭。\n\n## 3. 愚蠢的做法\n\n想象一下，当你的linux上运行了无数种后台程序：Apache、Nginx、MySQL、MongoDB、Redis...\n\n这时候你想要关掉这里面的某些软件，或者是你仅仅只是修改了配置文件而需要重启一下这些程序，按照上面的做法你可能需要先找到进程的id、再发出关闭信号、再找找用什么命令能够启动，很麻烦对吧？你仅仅只是想重启一下而已。\n\n## 4. 聪明的做法\n\n> 在一些旧版本的linux中使用init.d和service来完成\n\n有没有什么可以帮我处理好这些繁琐的流程呢？\n\n幸运的是在linux里你可以借助`Systemd`来完成这些事情，前提是你告诉Systemd该如何去管理你的这些程序，也就是用规定的格式去编写一些配置信息。\n\n更幸运的是，如果你通过linux自带的包管理如`yum`、`apt`、`pacman`来安装软件，例如借助命令`yum install nginx`来安装Nginx，包管理软件已经自动帮你完成了Systemd有关配置信息的编写，你只需要知道包管理为你配置的服务**叫什么名字**就可以。\n\n> 留意！并不是所有的软件配置名称都相同。\n\n显然对于Nginx而言，配置的名称就叫做`nginx`，因此你可以这样对Nginx操作：\n\n- 启动：`sudo systemctl start nginx`\n- 重启：`sudo systemctl restart nginx`\n- 关闭：`sudo systemctl stop nginx`\n\n当你仅仅是修改了Nginx的配置文件需要重启时，你只需要一条命令就可以完成那些繁琐的过程，针不戳。\n\n## 你可以在哪些地方找到Service\n\n## 自己动手配置Service\n\n## 参考文章\n\n- [https://tldp.org/LDP/solrhe/Securing-Optimizing-Linux-RH-Edition-v1.3/chap3sec21.html](https://tldp.org/LDP/solrhe/Securing-Optimizing-Linux-RH-Edition-v1.3/chap3sec21.html)\n- [http://www.cnitblog.com/luckydmz/archive/2020/06/28/92250.html](http://www.cnitblog.com/luckydmz/archive/2020/06/28/92250.html)\n- [http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html](http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html)\n- [http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html](http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html)\n- [https://tldp.org/LDP/sag/html/major-services.html](https://tldp.org/LDP/sag/html/major-services.html)\n- [https://tldp.org/LDP/solrhe/Securing-Optimizing-Linux-RH-Edition-v1.3/chap3sec21.html](https://tldp.org/LDP/solrhe/Securing-Optimizing-Linux-RH-Edition-v1.3/chap3sec21.html)\n","excerpt":"本文不会涉及很多专业的表达，因为我并不喜欢那些晦涩难懂的定义，并且事实上我也记不住那些定义。。。 1. 我说的Service是什么 我假设你已经接触过Apache、Nginx这类HTTP服务器，又或者是MySQL、MongoDB、Redis这类数据库。 无论是 HTTP…"},{"slug":"posts/note/flutter-widget-usage","title":"Flutter 组件用法","content":"---\ntitle: \"Flutter 组件用法\"\ndate: 2020-12-30T15:48:53+08:00\ncategories: [\"note\"]\ntags: [\"flutter\"]\ndraft: false\n---\n\n注意：本文为个人笔记，仅为简单的记录，内容未经过整理，也许无法对你产生什么帮助，请酌情参考。\n\n## 子控件位置控制\n\n- Align：可以设置预设效果，以及自定义坐标\n- Center：Center控件继承自Align，居中效果\n\n## 导航\n\n- Drawer：Drawer是一个抽屉导航组件，导航一般使用底部导航BottomNavigationBar或者抽屉导航。\n- BottomNavigationBar：类似于微信底部的导航效果。\n- FlexibleSpaceBar：AppBar的一部分，它可以扩展，折叠，延伸，最常用于SliverAppBar.flexibleSpace字段。\n- Tab：Material 风格 tab，用于TabBar的tab。Tab可以单独作为一个控件使用，但通常情况下作为TabBar的tabs。\n- TabBar：是一排水平的标签，可以来回切换。\n- TabBarView：TabBar 一般情况下和TabBarView一起使用，TabBarView用于选择不同的TabBar，TabBarView显示对应的View。\n- TabPageSelector：小圆圈指示器，个数取决于TabController，通常和TabBarView配合使用。\n\n## 容器\n\n- SizedBox：本身是固定宽高的，可以没有子容器，因此很适合用作容器间的间隙\n- AspectRatio：可以设定宽高比例的容器\n- FractionallySizedBox：可以相对于父容器尺寸百分比设定的容器\n- Container：最常用的组件，也是用法最复杂的一个。适用于不仅有尺寸的约束，还有装饰（颜色、边框、等）、内外边距等需求的情况。\n- OverflowBox：溢出父容器显示,允许child超出父容器的范围显示\n- SizedOverflowBox：是SizedBox与OverflowBox的结合体。一个特定大小的widget，但是会将它的原始约束传递给它的子组件，它可能会溢出，超出部分也可以被渲染显示。\n- SafeArea：现如今的手机已经不能提供给应用程序规整的矩形界面了，一些带圆角或者是刘海屏让应用程序的布局更加复杂，甚至是需要单独适配，这对开发者来来太糟糕了。因此SafeArea控件应用而生，SafeArea通过MediaQuery检测屏幕的尺寸使应用程序的大小与屏幕适配。\n- SliverSafeArea：SliverSafeArea的功能和SafeArea是一样的，区别就是SliverSafeArea用于Sliver控件。\n- TextSpan：html里有个span这里有个TextSpan，作用基本相同，文字放一行，text与children任选一样填写。\n\n## 按钮\n\n- RaisedButton：是一个material风格”凸起“的按钮\n- OutlineButton：带表框无背景的按钮\n- DropdownButton：下拉选择按钮\n- RawMaterialButton\n- PopupMenuButton：菜单展开按钮\n- BackButton：返回按钮，本质是个IconButton，Android和IOS平台显示的图标是不一样的，点击时默认执行 `Navigator.maybePop` 即如果路由栈有上一页则返回到上一页。\n- CloseButton：CloseButton是一个material风格的关闭按钮，本身是一个IconButton，点击时默认执行 `Navigator.maybePop`，和BackButton适用场景不同，BackButton适用于全屏的页面，而CloseButton适用于弹出的Dialog。\n- ButtonBar：并不是一个单独的按钮控件，而是末端对齐的容器类控件，当在水平方向上没有足够空间时候，按钮将整体垂直排列，而不是换行。\n- CupertinoButton：iOS 风格按钮\n- ExpandIcon：旋转展开/折叠按钮的组件\n- FloatingActionButton：通常和Scaffold一起使用，在底部导航栏嵌入按钮。\n- Switch：material风格的开关组件。\n- CupertinoSwitch：ios风格开关组件。\n- ToggleButtons：组件将多个组件组合在一起，并让用户从中选择。\n\n\n## 布局\n\n- Row/Column：Row和Column是多子控件的容器类控件，Row控件水平布局，Column控件垂直布局。\n- Baseline：基准线布局，是指将所有的元素都统一的放在一条水平线上，是根据child的baseline，来调整child的位置，即在不同的child都处在规定的基准线位置，多用文字排版中的时候，就算是不同大小的文字处于同一水平线上。\n- Flexible：组件可以控制Row、Column、Flex的子控件占满父控件，比如，Row中有3个子控件，2边的固定宽，中间的占满剩余的空间。\n- Expanded：Expanded继承字Flexible，fit参数固定为FlexFit.tight，也就是说Expanded必须（强制）填满剩余空间。\n- Spacer：Spacer的通过Expanded的实现的，和Expanded的区别是：Expanded可以设置子控件，而Spacer的子控件尺寸是0，因此Spacer适用于撑开Row、Column、Flex的子控件的空隙。\n- Flow：流式小部件，同类型的有Wrap，Row等，Flow的特点是可以调整子组件的位置和大小，结合Matrix4绘制出各种酷炫的效果如水平展开/收起菜单。\n- NavigationToolbar：是一个布局控件，控制3个子组件。\n- Wrap：子控件进行水平或者垂直方向布局，且当空间用完时，Wrap会自动换行，也是常说的流式​布局。\n\n## 控件形状\n\nFlutter中很多组件都有一个叫做 shape 的属性，类型是 ShapeBorder ，比如 Button 类、 Card 等组件， shape 表示控件的形状，系统已经为我们提供了很多形状。\n\n- BeveledRectangleBorder：斜角矩形边框（某些值下就是矩形）\n- Border：Border允许单独设置每一个边上的线条样式.\n- BorderDirectional：BorderDirectional和Border基本一样，区别就是BorderDirectional带有阅读方向，大部分国家阅读是从左到右，但有的国家是从右到左的，比如阿拉伯等。\n- CircleBorder：圆形\n- ContinuousRectangleBorder：连续的圆角矩形，直线和圆角平滑连续的过渡，和RoundedRectangleBorder相比，圆角效果会小一些。\n- RoundedRectangleBorder：圆角矩形\n- StadiumBorder：类似足球场的形状，两边圆形，中间矩形\n- OutlineInputBorder：带外边框\n- UnderlineInputBorder：下划线边框\n\n## 勾选框\n\n- Checkbox：Checkbox是勾选框控件，只有一个勾\n- CheckboxListTile：通常情况下，我们不直接使用Checkbox，而是使用CheckboxListTile，因为我们需要Checkbox后面添加说明\n\n## 数值选择器\n\n- Slider：滑动选择器\n- RangeSlider：如果想要选择两个值，起始与结束\n- CupertinoSlider：iOS风格滑动选择器\n\n## 进度条\n\n- LinearProgressIndicator：水平进度指示器\n- CircularProgressIndicator：圆形进度条\n- CupertinoActivityIndicator：ios风格的圆形指示器\n- RefreshProgressIndicator：刷新指示器，通常用于下拉刷新\n\n## 裁剪子组件\n\n- ClipRect：矩形裁剪子组件\n- ClipRRect：圆角裁剪\n- ClipOval：椭圆形裁剪\n- ClipPath：根据设置的路径裁剪，我们自定义裁剪路径也可以使用系统提供\n- CustomClipper：抽象类，可以自定义形状，配合ClipPath使用\n\n## 视觉效果\n\n- ColorFiltered：实现类似“滤镜”效果\n- LinearGradient：线性渐变\n- RadialGradient：放射状渐变\n- SweepGradient：扇形渐变\n\n## 弹出框\n\n- CupertinoActionSheet：iOS 风格底部弹出的提示框\n- CupertinoActionSheetAction：配合CupertinoActionSheet，提供子控件和onPressed回调\n- AlertDialog：Material风格，弹出框进行2次确认，以避免用户的误操作\n- CupertinoAlertDialog：ios风格的AlertDialog\n- Dialog：Dialog可以定制任何对话框\n- showDialog：用于弹出Material风格对话框\n- showCupertinoDialog：用于弹出ios风格对话框\n- showGeneralDialog：不满足你的需求，还可以使用showGeneralDialog自定义提示框\n- showAboutDialog：用于描述当前App信息，底部提供2个按钮，查看许可按钮和关闭按钮\n- showBottomSheet：在最近的Scaffold父组件上展示一个material风格的bottom sheet，位置同Scaffold组件的bottomSheet，如果Scaffold设置了bottomSheet，调用showBottomSheet抛出异常。\n- showModalBottomSheet：从底部弹出，通常和BottomSheet配合使用。\n- showCupertinoModalPopup：showCupertinoModalPopup 展示ios的风格弹出框，通常情况下和CupertinoActionSheet配合使用。\n- showSearch：直接跳转到搜索页面\n\n## 滚动组件\n\n- SingleChildScrollView：只能包含单个组件的滚动组件，没有“懒加载”模式。如果内容较多，建议使用ListView。\n- SliverAppBar：可以实现滑动时页面头部区域展开、折叠的效果，标题会吸附在页面头部。\n- SliverPersistentHeader：控件当滚动到边缘时根据滚动的距离缩小高度，有点类似 SliverAppBar 的背景效果。\n- SliverFillRemaining：此组件充满视口剩余空间，通常用于最后一个sliver组件，用来告知用户已经到底了。\n- SliverFillViewport：生成的每一个item都垂直占满全屏\n- SliverList：要同时滚动ListView和GridView的时候可以使用SliverList和SliverGrid。\n- SliverFixedExtentList：是sliver系列组件之一，和SliverList用法一样，唯一的区别就是SliverFixedExtentList是固定子控件的高度的，SliverFixedExtentList比SliverList更加高效。\n- SliverPrototypeExtentList：SliverPrototypeExtentList和SliverList用法一样，区别是SliverPrototypeExtentList的高度由prototypeItem控件决定。SliverPrototypeExtentList通常用于不确定item高度，随prototypeItem变化的场景,比如调整整个App字体的大小，字体越大，需要的高度越高。如果使用SliverFixedExtentList指定具体的高度，会出现字体显示不全的状况。\n- SliverGrid：同上。\n- SliverLayoutBuilder：组件的约束条件提供子组件，比如当用户向下划动时，盒子显示红色，向上滑动时显示蓝色。\n- SliverOpacity：可设置子组件透明度。\n- SliverPadding：是sliver系列的Padding组件，配合CustomScrollView使用。\n- CustomScrollView：CustomScrollView是使用Sliver组件创建自定义滚动效果的滚动组件，CustomScrollView就像一个粘合剂，将多个组件粘合在一起，具统一的滚动效果。\n- SliverToBoxAdapter：只能包含sliver系列组件，如果包含普通的组件如何处理？使用SliverToBoxAdapter包裹。\n- GlowingOverscrollIndicator：是Android平台ListView列表滑动到底部时在滑动出现的水波纹效果，此控件配合ScrollNotification使用。\n- GridView：是一个可滚动的，2D数组控件。\n- NestedScrollView：可以在其内部嵌套其他滚动视图的滚动视图，其滚动位置是固有链接的。 例如，浏览内部列表以滚动到顶部不会导致外部[ScrollView]中的[SliverAppBar]折叠以展开。\n- Scrollable：它实现了滚动小部件的交互模型，包括手势识别，但没有提供如何显示实际子项的视口。基本不会直接使用Scrollable控件，而是使用ListView，GridView。\n- Scrollbar：Material风格的滚动条，ListView等可滚动控件默认情况下是没有滚动指示器的。\n- CupertinoScrollbar：iOS风格的滚动条，用法和Scrollbar一样。\n\n\n## 内容控件\n\n- Divider：是一个分割线控件。\n- VerticalDivider：垂直分割线。\n- MaterialBanner：Material 风格的标语（Banner）控件。\n- Stepper：展示一系列步骤进度的控件。\n- Table：表格组件，适合不滑动的网格控件，尤其是如果拥有不同大小的小控件。嵌套的行和列可能会比较乱，但Table组件组件提供了一致性并为您调整子窗口的大小。\n- Text：显示文本的组件，最常用的组件，都没有之一。\n- TextAlign：设置文本的对齐方式。\n\n## 功能控件\n\n- FractionalTranslation：根据Offset平移控件，比如设置Offset的dx为0.25，那么在水平方向上平移控件1/4的宽度。\n- Dismissible：可通过左滑或者右滑清除列表项。\n- Draggable：可以让我们拖动组件。\n- DragTarget：指定一个目的地，Draggable组件可以拖动到此控件。\n- LongPressDraggable：继承自Draggable，因此用法和Draggable完全一样，唯一的区别就是LongPressDraggable触发拖动的方式是长按。\n- DraggableScrollableSheet：组件可以在屏幕上拖动，builder属性需要返回其子控件，可以是任何类型的子控件，一般返回一个ListView。\n- ErrorWidget：屏蔽错误页面组件，ErrorWidget的构造函数的参数是exception的对象，然后返回一个内容是exception message信息的RenderBox。\n- FutureBuilder：当有一个Future（异步）任务需要展示给用户时，可以使用FutureBuilder控件来完成，比如向服务器发送数据成功时显示成功提示。\n- StreamBuilder：用于异步接收数据更新组件，与FutureBuilder不同的地方在于StreamBuilder可以接收多个异步操作。\n- GestureDetector：手势识别的组件，可以识别点击、双击、长按事件、拖动、缩放等手势。\n- TextSelectionGestureDetector：是一个文本选择的手势识别控件，和GestureDetector的区别是GestureDetector只能处理单击或者双击事件，而TextSelectionGestureDetector可以同时处理单击和双击事件。\n- GridPaper：绘制一个像素宽度的直线网格。\n- MaterialTapTargetSize：MaterialTapTargetSize并不是一个组件，是配置组件点击区域大小的属性，很多组件都有materialTapTargetSize属性。\n- MediaQuery：不会直接将MediaQuery当作一个控件，而是使用MediaQuery.of获取当前设备的信息。\n- Navigator：管理路由的控件。\n- Semantics：用于屏幕阅读器、搜索引擎、或者其他语义分析工具。\n- StatefulBuilder：提供了局部更新控件的方法，当StatefulWidget中控件树较大时，更新一个属性导致整个树重建，消耗性能，而使用StatefulBuilder能有效的提高性能。\n- Tooltip： 一个消息提示组件，当用户点击或者长按时显示提示，在屏幕阅读器能够使它语音化，这有助于视力障碍人士阅读。\n- ValueListenableBuilder：在开发应用程序的时候有些数据是全局的，贯穿整个应用程序，比如用户信息，我们希望当这些数据发生变化时，应用程序任何页面的数据都更新。\n- Visibility：控制子组件隐藏/可见的组件。\n- WillPopScope：用于处理是否离开当前页面。\n\n## 文本、输入控件\n\n- FormField：表单控件，此控件包含表单的状态，方便更新UI，通常情况下，我们不会直接使用FormField，而是使用TextFormField。\n- TextFormField：TextFormField继承自FormField，是一个输入框表单。\n- Form：Form组件是一个容器类控件，可以包含多个FormField表单控件，这样的好处是统一管理。\n- DayPicker：显示给定月份的日期，并允许选择一天。这些天以矩形网格排列，一周的每一天都有一列。\n- MonthPicker：可选择的月份选择器。\n- YearPicker：年份选择器。\n- showDatePicker：并不是一个新的控件，而是封装了YearPicker和MonthPicker，并进行了联动。\n- showTimePicker：时间选择器只能通过showTimePicker的方式来调用。\n- CupertinoDatePicker：ios风格的日期选择器。\n- CupertinoTimerPicker：ios风格的时间选择器。\n- SelectableText：文本可以被选中，并可以复制、剪切。\n- TextInput：不是组件，而是Flutter与原生交互的服务，控制键盘的显示。TextField组件的TextInputAction属性通过此服务实现。\n- EditableText：EditableText是一个基本的文本输入组件，此组件和TextInput一起让用户编辑输入框的内容，提供滚动、选择、光标运动，但不提供焦点管理。通常情况下我们不会直至使用此组件，而是使用Material风格的TextField组件。\n- TextField：TextField是文本输入组件，即输入框，常用组件之一。\n- CupertinoTextField：ios风格的输入框。\n\n## 过渡动画\n\n- Hero：Hero是我们常用的过渡动画，当用户点击一张图片，切换到另一个页面时，这个页面也有此图，那么使用Hero组件就在合适不过了。\n- TweenAnimationBuilder：开发App中有时需要一个简单的动画，可以通过AnimationController实现，但比较麻烦，有没有一个内置的隐式动画组件来解决这个问题？TweenAnimationBuilder可以满足你对所有自定义动画的需求，而不用关系AnimationController。\n\n## 参考文章\n\n- [Flutter | 老孟](http://laomengit.com)\n","excerpt":"注意：本文为个人笔记，仅为简单的记录，内容未经过整理，也许无法对你产生什么帮助，请酌情参考。 子控件位置控制 Align：可以设置预设效果，以及自定义坐标 Center：Center控件继承自Align，居中效果 导航 Drawer：Drawer…"},{"slug":"posts/note/macos-brew-flutter","title":"macOS下通过brew搭建Flutter开发环境","content":"---\ntitle: \"macOS下通过brew搭建Flutter开发环境\"\ndate: 2020-12-29T20:28:13+08:00\ncategories: [\"note\"]\ntags: [\"brew\", \"macos\", \"flutter\", \"android\", \"genymotion\"]\ndraft: false\n---\n\n注意：本文目前为个人笔记，不保证内容能为你所用，请根据文章发布日期酌情参考。\n\n## 1. 安装\n\n> 前提：安装了 brew ，本文基于 Homebrew 2.7.1\n\n目标：完全通过 brew 安装所需环境，不安装 Android Studio (利用 VSCode 开发)。\n\n```bash\n\n# 安装 genymotion 安卓虚拟机，这个比 AndroidStudio 自带的快\nbrew install genymotion\n\n# 安装 flutter\nbrew install flutter\n\n# 运行 flutter doctor 下载一些需要的依赖，比如 dart\nflutter doctor\n\n# 安装 Java 8，Android SDK 用高版本会报错\nbrew cask install adoptopenjdk8\n\n# 安装 Android SDK 管理工具，本文不面向 iOS 开发\n# 个人习惯 VSCode + Terminal 开发，不想装 Andorid Studio\n# 如果是安装 Android Studio 则可以不安装这个\nbrew tap caskroom/cask\nbrew install android-sdk\n\n# 下载 sdk ，因为的虚拟机我安装的是 Android10 对应的是 29 版本\nsdkmanager \"platform-tools\" \"platforms;android-29\" 'build-tools;29.0.2'\n\n```\n\n### 1.1. 设置ANDROID_SDK_ROOT\n\n在我的环境中，安装完 `android-sdk` 后，安装目录会被链接到 `/usr/local/share/android-sdk`（请检查你的机器上该目录是不是存在的）。\n\n设置 `ANDROID_SDK_ROOT` 为该目录：\n\n```bash\nexport ANDROID_SDK_ROOT=/usr/local/share/android-sdk\n```\n\n如果你发现没有 `/usr/local/share/android-sdk` 这个目录，那你也可以通过 `brew info android-sdk` 查看实际安装目录，结果如下所示，我的安装目录是 `/usr/local/Caskroom/android-sdk/4333796`。\n\n```bash\nandroid-sdk: 4333796\nhttps://developer.android.com/studio/releases/sdk-tools\n/usr/local/Caskroom/android-sdk/4333796 (1,031 files, 113.8MB)\n...\n...\n...\n```\n\n于是设置 `ANDROID_SDK_ROOT` 为实际安装目录：\n\n```bash\nexport ANDROID_SDK_ROOT=/usr/local/Caskroom/android-sdk/4333796\n```\n\n### 1.2. 启动虚拟机\n\ngenymotion 需要一个账户登录，需要先在[官网注册](https://www.genymotion.com/)，进入软件后选择一个要模拟的机型（比如 Google Pixel 3）添加即可，程序会自动下载需要的文件并安装，安装完成后启动虚拟机。\n\n## 2. 检验\n\n### 2.1. 检验flutter及其依赖是否可用\n\n`flutter doctor`，结果如下，注意其中的 `Flutter` 和 `Android toolchain` 打了勾就行。\n\n```bash\n➜  share flutter doctor\nDoctor summary (to see all details, run flutter doctor -v):\n[✓] Flutter (Channel stable, 1.22.5, on Mac OS X 10.15.6 19G73 darwin-x64, locale zh-Hans-CN)\n\n[✓] Android toolchain - develop for Android devices (Android SDK version 29.0.2)\n[✗] Xcode - develop for iOS and macOS\n    ✗ Xcode installation is incomplete; a full installation is necessary for iOS development.\n      Download at: https://developer.apple.com/xcode/download/\n      Or install Xcode via the App Store.\n      Once installed, run:\n        sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer\n        sudo xcodebuild -runFirstLaunch\n    ✗ CocoaPods not installed.\n        CocoaPods is used to retrieve the iOS and macOS platform side's plugin code that responds to your plugin usage on the\n        Dart side.\n        Without CocoaPods, plugins will not work on iOS or macOS.\n        For more info, see https://flutter.dev/platform-plugins\n      To install:\n        sudo gem install cocoapods\n[!] Android Studio (not installed)\n[!] IntelliJ IDEA Ultimate Edition (version 2020.1.2)\n    ✗ Flutter plugin not installed; this adds Flutter specific functionality.\n    ✗ Dart plugin not installed; this adds Dart specific functionality.\n[✓] VS Code (version 1.52.1)\n[!] Proxy Configuration\n    ! NO_PROXY is not set\n[✓] Connected device (1 available)\n\n! Doctor found issues in 4 categories.\n➜  share\n```\n\n\n### 2.2. 检验是否正常连接虚拟机设备\n\n终端执行 `flutter devices`，内容如下则正常：\n\n```bash\n➜  ~ flutter devices\n1 connected device:\n\nGoogle Pixel 3 (mobile) • 192.168.56.101:5555 • android-x86 • Android 10 (API 29)\n```\n\n## 3. 参考文章\n\n- [Installing Android SDK Tools\n](https://guides.codepath.com/android/installing-android-sdk-tools)\n- [Mac OS下安装和配置android-sdk\n](https://gist.github.com/Erichain/0ac3a6aaca0c28ad6551)\n- [Setup Android SDK on a Mac](https://gist.github.com/agrcrobles/165ac477a9ee51198f4a870c723cd441)\n","excerpt":"注意：本文目前为个人笔记，不保证内容能为你所用，请根据文章发布日期酌情参考。 1. 安装 前提：安装了 brew ，本文基于 Homebrew 2.7.1 目标：完全通过 brew 安装所需环境，不安装 Android Studio (利用 VSCode 开发)。 1.1. 设置ANDROID_SDK_ROOT…"},{"slug":"posts/uncategorized/pdf-shop","title":"正版电子书购买平台汇总","content":"---\ntitle: \"正版电子书购买平台汇总\"\ndate: 2020-12-24T20:26:08+08:00\ncategories: [\"uncategorized\"]\ntags: [\"pdf\", \"e-book\"]\ndraft: false\n---\n\n1. [图灵社区](https://www.ituring.com.cn/)：购买后可以在线观看，也可以获取到pdf、mobi的下载链接，书里带有个人信息水印。\n2. [亚马逊Kindle电子书](https://www.amazon.cn/b?&node=116169071&tag=baiduiclickcn-23&ref=DEP_18119_SY_3285)：购买后可以使用Kindle观看，也可以使用亚马逊免费提供的Kindle阅读器客户端观看。\n3. [多看阅读](https://www.duokan.com/)：对Kindle支持较好，也支持iOS和Android的客户端，电脑只能在线阅读，不清楚能不能支持Kindle阅读器。\n4. [京东电子图书](https://e.jd.com/)：只能在线观看，不太友好。\n5. [异步社区](https://www.epubit.com/)：类似图灵社区。\n6. [工程科技数字图书馆](http://ebooks.cmanuf.com/)：机械工业出版社相关电子书，好像可以在线阅读，尝试了一下没成功。\n7. [当当云阅读](http://e.dangdang.com/)：可以使用专门的阅读器阅读，电脑只能在线阅读。\n8. [OiiPDF.COM](https://oiipdf.com/)：不太明白来源，似乎很多编程书籍PDF可以免费下载。\n","excerpt":"图灵社区 ：购买后可以在线观看，也可以获取到pdf、mobi的下载链接，书里带有个人信息水印。 亚马逊Kindle电子书 ：购买后可以使用Kindle观看，也可以使用亚马逊免费提供的Kindle阅读器客户端观看。 多看阅读 ：对Kindle支持较好，也支持iOS和Android…"},{"slug":"posts/code/postman-security/","title":"SpringBoot使用Security认证时如何使用Postman进行测试？","content":"---\ntitle: \"SpringBoot使用Security认证时如何使用Postman进行测试？\"\ndate: 2020-12-08T21:16:06+08:00\nresources:\n- name: \"featured-image\"\n  src: \"1.png\"\ncategories: [\"code\"]\ntags: [\"springboot\",\"postman\",\"security\"]\ndraft: false\n---\n\n如图\n","excerpt":"如图"},{"slug":"posts/code/windows-tomcat-startup-garbled/","title":"Windows下使用startup.bat启动Tomcat输出乱码的原因探究、解决方案","content":"---\ntitle: \"Windows下使用startup.bat启动Tomcat输出乱码的原因探究、解决方案\"\ndate: 2020-12-08T21:25:28+08:00\nimages: []\ncategories: [\"code\"]\ntags: [\"java\", \"tomcat\", \"windows\", \"乱码\"]\ndraft: false\n---\n\n![startup.bat输出乱码](1.png)\n\n首先找到输出日志的配置文件\n![输出日志配置文件】](2.png)\n\n打开`logging.properties`，搜索`log`，可以发现以下配置\n![配置文件](3.png)\n\n再看看启动bat的cmd的属性\n![cmd属性](4.png)\n\n很明显编码是GBK，所以乱码的原因实锤了，知道了原因就好解决了\n\n1. 把`cmd`的编码改为`utf-8`\n2. 把`tomcat`的日志输出改成`GBK`\n\n由于方法`2`改配置文件比较方便，并且对其他程序没有影响，故选用`2`\n\n修改`logging.properties`\n\n```properties\njava.util.logging.ConsoleHandler.encoding = UTF-8\n```\n\n改为\n\n```properties\njava.util.logging.ConsoleHandler.encoding = GBK\n```\n\n保存文件，重启bat\n\n![正常输出](5.png)\n\n不再乱码了，大功告成！\n","excerpt":"首先找到输出日志的配置文件\n 打开 logging.properties ，搜索 log ，可以发现以下配置\n 再看看启动bat的cmd的属性\n 很明显编码是GBK，所以乱码的原因实锤了，知道了原因就好解决了 把 cmd 的编码改为 utf-8 把 tomcat 的日志输出改成 GBK 由于方法…"},{"slug":"posts/draft/os-process-2/","title":"操作系统系列之——深入进程","content":"---\ntitle: \"操作系统系列之——深入进程\"\ndate: 2020-12-29T11:09:42+08:00\ndraft: true\n---\n\n\n## 说明\n\n阅读本文之前，请确保你已经了解以下文章中提及到的那些知识点：\n\n- [操作系统系列之——程序](/posts/code/os-program/)\n- [操作系统系列之——进程](/posts/code/os-process/)\n- [操作系统系列之——文件描述符](/posts/code/os-fd/)\n\n前文 [操作系统系列之——进程](/posts/code/os-process/) 中简单地在概念层面介绍了进程，更注重于理解。本文则将更侧重于进程在操作系统中的细节。\n\n方便起见，以下的 Unix 泛指 Unix 系统和类 Unix 系统。\n\n## 进程的状态\n\n操作系统允许多个进程同时运行在电脑中，但进程可能很多，但 CPU 资源却是有限的，不可能所有进程每时每刻都能得到 CPU 资源进行执行，因此进程会在操作系统的调度下在不同的状态中切换，进程大致上可能的状态如下：\n\n- 运行态：此时进程正占用 CPU。\n- 就绪态：进程已经处于可运行状态，但由于其他进程已经占用 CPU ，该进程暂时无法占用。\n- 阻塞态：此时进程处于一种被动状态，他正在等待某些事件的发生，除非该事件发生，否则进程不能运行。\n\n进程状态会由于一些事件而发生转换：\n\n![进程状态图](process-status.drawio.png \"进程状态图\")\n\n1. 进程因为等待外部事件（例如，该进程发起了 io 请求后在等待 io 完成）而被阻塞。\n2. 调度程序选择了另一个进程，该进程失去 CPU。\n3. 调度程序重新选择了这个进程。\n4. 外部事件发生（例如，io 完成）。\n\n## 进程常见属性\n\n一个进程中会保存的许多的属性，这里取出一些后文会提到的属性：\n\n- 进程标识：Unix 中的每个进程都是独一无二的，他们通过进程 ID 来唯一标识，进程的 ID 也称为 **PID** 。\n- 父进程标识：属性名为 **PPID** ，进程用它来保存父进程的 PID ，下文中有关于父进程的说明。\n- 进程组标识：属性名为 **PGID** ，进程用它来保存进程组的 ID ，下文中有关于进程组的说明。\n\n## 进程之间的关系\n\nUnix 的进程之间存在一个明显的 **继承** 关系，除了第一个进程外，所有的新进程都是由系统中的旧进程创建的，创建者为父进程，被创建者为子进程，因此系统中的每个进程有且仅有一个父进程，但可以拥有零到多个子进程，同时拥有同一个父进程的所有进程被成为兄弟。\n\n在 Unix 中，大多数的进程都是 init 进程的后代，init 进程是 PID 为 1 的进程，它是系统中的第二个进程。\n\n> TODO：找地方放这一段\n> 内核在系统启动的最后阶段启动 init 进程，该进程读取系统的初始化脚本（initscript）并执行其他的相关程序，最终完成系统启动的整个过程。\n> 进程间的关系存放在 task_struct 中。每个 task_struct 包含一个指向其父进程 task_struct 的指针，叫做 **parent** 指针，还包含了一个称为 **children** 的子进程链表。\n\n在 Ubuntu14.04 下的部分进程关系如下图所示 ：\n\n![进程树](process-tree.drawio.png \"进程树\")\n\n> 你可以使用 `ps ajxf` 和 `pstree` 来查看进程的父子关系\n\n## 进程组\n\n![进程组](process-group.drawio.png \"进程组\")\n\n尽管在 UNIX 中进程是被 PID 所标识的，但系统在一些场景下需要用 “组” 的形式来标识多个进程，这些进程通常共同完成某个目标，在某些事件发生时，这些进程应该能收到同样的信号。\n\n系统为了以组的形式管理进程而引入了进程组的概念，进程组可以包含一个到多个进程，并且每个进程组也是独一无二的，有一个用来标识自己的 PGID 。\n\n### 进程组组长\n\n每个进程组都有一个组长，组长进程的特点是进程 ID 与 进程组 ID 相同，或者说进程组的 ID 就是由组长的 ID 决定的。\n\n### 进程离开与转移进程组\n\n当进程自身终止或主动转移到其他进程组时，进程则离开了当前进程组。\n\n### 进程组的生命周期\n\n组长可以创建一个进程组，再创建属于该组的进程。组长是否在组内与进程组是否存在无关，进程组是否存在取决于组内是否仍然存在至少一个进程。\n\n从进程组的创建开始，到最后一个进程离开的这段时间称之为进程组的生存期。\n\n## 控制终端\n\n// TODO\n\n## 会话\n\n会话（ session ）是一个或多个进程组的集合。\n// TODO 会话用来干嘛\n\n若在终端中依次执行以下命令：\n\n```bash\nproc1 | proc2 &\nproc3 | proc4 | proc5\n```\n\n将能得到如下图所示的会话：\n\n![会话](process-session.drawio.png \"会话\")\n\n### 前台进程组\n\n会话中的所有进程组中，只有 **一个** 是前台进程组，tty 的输输入和信号（例如通过 ^C，^Z 产生的）会进入这个前台进程组。\n\n#### 查看前台进程组\n\n进程可以通过函数调用 `tcgetpgrp(fd)` 来查看它所在会话的前台进程组，函数调用中的 `fd` 是该进程控制 tty 的文件描述符，若该会话不存在前台进程组，则函数随机返回大于 1 但并不代表任何 GID 的整数。\n\n#### 设置前台进程组\n\n// TODO tty 与 会话存在关联\n\n进程可以通过函数调用 `tcsetpgrp(fd, pgrp)` 来设置其会话组中的前台进程组，函数调用中的 `fd` 是该进程控制 tty 的文件描述符、 `pgrp` 是该进程所在会话中的一个进程组，并且要求设置时 `fd` 仍然与该进程所在会话存在关联。\n\n#### 控制 tty 的文件描述符\n\n`fd` 是控制 tty 的文件描述符，根据定义，`/dev/tty` 指控制 tty，并且完全独立于标准输入输出的重定向。打开对应名字的 `/dev/tty` 即可获得对应的控制 tty 的文件描述符\n\n在 Ubuntu14.04 下的 `/dev` 文件夹内容如下图所示，可以看到里面有很多个 `tty` ：\n\n> `ctermid()` 函数可以获取控制终端的名字，在 POSIX 标准中，该函数返回 `/dev/tty`\n\n```bash\njabin@ubuntu-linux14:/dev$ ls /dev\nautofs           loop0               ram13     sr0     tty26  tty49   ttyS13  ttyS8\nblock            loop1               ram14     sr1     tty27  tty5    ttyS14  ttyS9\nbsg              loop2               ram15     stderr  tty28  tty50   ttyS15  ttyprintk\nbtrfs-control    loop3               ram2      stdin   tty29  tty51   ttyS16  uhid\nbus              loop4               ram3      stdout  tty3   tty52   ttyS17  uinput\ncdrom            loop5               ram4      tty     tty30  tty53   ttyS18  urandom\nchar             loop6               ram5      tty0    tty31  tty54   ttyS19  vcs\nconsole          loop7               ram6      tty1    tty32  tty55   ttyS2   vcs1\ncore             mapper              ram7      tty10   tty33  tty56   ttyS20  vcs2\ncpu              mcelog              ram8      tty11   tty34  tty57   ttyS21  vcs3\ncpu_dma_latency  mem                 ram9      tty12   tty35  tty58   ttyS22  vcs4\ncuse             net                 random    tty13   tty36  tty59   ttyS23  vcs5\ndisk             network_latency     rfkill    tty14   tty37  tty6    ttyS24  vcs6\necryptfs         network_throughput  rtc       tty15   tty38  tty60   ttyS25  vcs7\nfb0              null                rtc0      tty16   tty39  tty61   ttyS26  vcsa\nfd               port                sda       tty17   tty4   tty62   ttyS27  vcsa1\nfull             ppp                 sda1      tty18   tty40  tty63   ttyS28  vcsa2\nfuse             psaux               sda2      tty19   tty41  tty7    ttyS29  vcsa3\nhidraw0          ptmx                sda5      tty2    tty42  tty8    ttyS3   vcsa4\nhidraw1          pts                 sg0       tty20   tty43  tty9    ttyS30  vcsa5\nhpet             ram0                sg1       tty21   tty44  ttyS0   ttyS31  vcsa6\ninput            ram1                sg2       tty22   tty45  ttyS1   ttyS4   vcsa7\nkmsg             ram10               shm       tty23   tty46  ttyS10  ttyS5   vga_arbiter\nlog              ram11               snapshot  tty24   tty47  ttyS11  ttyS6   vhost-net\nloop-control     ram12               snd       tty25   tty48  ttyS12  ttyS7   zero\n```\n\n### 后台进程组\n\n会话中所有 **非前台的** 进程组都是后台进程组。用户的键盘会与前台进程进行交互，因此后台进程是不应该与控制终端产生联系的。\n\n如果一个后台进程尝试往一个控制终端读取数据，它将会收到 `SIGTTIN` 信号，通常该信号会导致该后台进程终止，但作业控制程序将会注意到这一点并且允许用户通过 `fg` 命令来挽救该进程，使该进程转为前台进程继续运行并且能够向终端读取数据。\n\n但如果一个后台进程忽略或者 blocks 了 `SIGTTIN` 信号，又或者它的进程组是孤儿进程组，那么 `read()` 将返回 `EIO` 错误，并且不会发出信号。这意味着如果它看不到信号，那么它就会得到错误返回。实际上，这个机制是为了告诉进程现在不允许从终端读取数据。\n\n当一个后台进程向前台进程写入数据时，它可能会收到 `SIGTTOU` 信号，是否收到该信号取决于当前的系统设置，该设置默认处于关闭状态：\n\n- 开启：`stty tostop`\n- 关闭：`stty -tostop`\n- 查看所有配置：`stty -a`\n\n同样的，在 `tostop` 被设置的前提下，如果一个后台进程忽略或者 blocks 了 `SIGTTIN` 信号，又或者它的进程组是孤儿进程组，那么 `write()` 将返回 `EIO` 错误，并且不会发出信号。\n\n### 孤儿进程组\n\n进程组组长是进程的第一个成员，但它有可能会比进程组中的其他进程更快终止，然后该进程组将处于一个没有组长的状态。\n\n当一个进程组中的每个成员的父进程都在该进程组中或都不在该会话中时，该进程组被称为孤儿进程组。特别的，会话 leader 所在的进程组一定是一个孤儿进程组。\n\n// TODO： 整理意思\n\n孤儿进程组命名的意义在于，或许进程组 leader 的父进程是一个作业控制 shell （在同一个会话但不同的进程组中），只要该父进程存在，它可以处理进程组成员的启动或终止，但当它终止时，也许没有人能够继续已停止的进程。因此，这些停止的进程将被发送 `SIGHUP` 信号，以此来让他们终止，除非他们主动处理或忽视该信号，然后发出 `SIGCONT` 信号来使他们继续。\n\n注意，会话领导者的进程组已经是孤儿进程组了，因此当会话领导者死亡时不会发送任何信号。\n\n// TODO：谜语人\n\n再次注意，一个进程组可以用两种方式终止进程来成为孤儿进程组，一种是该进程是父进程且它不在该进程组中，另一种是它的父进程在同一个会话的其他进程组且它是该进程组中的最后一个元素。此外，进程组还可以不通过终止进程的方式成为孤儿进程，即进程组的成员被移到其他的进程组。\n\n## 参考文章\n\n- *Linux内核设计与实现——机械工业出版社*\n- *Unix环境高级编程（第四版）*\n- *Unix操作系统设计：7.2.2 进程组*\n- https://en.wikipedia.org/wiki/Tty_(unix)\n- https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B\n- https://www.win.tue.nl/~aeb/linux/lk/lk-10.html\n- https://webhostinghero.org/how-to-create-a-process-group-in-linux/\n- https://man.cx/credentials(7)\n- https://petertc.medium.com/session-process-group-and-signal-in-linux-7fbe85c0b0c5\n- http://epaper.gotop.com.tw/PDFSample/AXP015900.pdf\n- https://docstore.mik.ua/orelly/unix/upt/ch12_07.htm","excerpt":"说明 阅读本文之前，请确保你已经了解以下文章中提及到的那些知识点： 操作系统系列之——程序 操作系统系列之——进程 操作系统系列之——文件描述符 前文  操作系统系列之——进程  中简单地在概念层面介绍了进程，更注重于理解。本文则将更侧重于进程在操作系统中的细节。 方便起见，以下的 Unix 泛指 Unix…"}]